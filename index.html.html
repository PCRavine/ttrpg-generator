<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#6366f1">
    <meta name="description" content="Smart Random Generator - Create custom random tables for TTRPGs">
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiU21hcnQgUmFuZG9tIEdlbmVyYXRvciIsInNob3J0X25hbWUiOiJSYW5kIEdlbiIsImRlc2NyaXB0aW9uIjoiQ3JlYXRlIGN1c3RvbSByYW5kb20gdGFibGVzIGZvciBUVFJQR3MiLCJzdGFydF91cmwiOiIvIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiI2ZmZmZmZiIsInRoZW1lX2NvbG9yIjoiIzYzNjZmMSIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBeE1qZ2dNVEk0SWo0OGNtVmpkQ0IzYVdSMGFEMGlNVEk0SWlCb1pXbG5hSFE5SWpFeU9DSWdabWxzYkQwaUl6WXpOalptTVNJdlBqeDBaWGgwSUhnOUlqWTBJaUI1UFNJMk5DSWdabWxzYkQwaUkzZG9hWFJsSWlCbWIyNTBMWE5wZW1VOUlqUTRJaUJtYjI1MExYZGxhV2RvZEQwaVltOXNaQ0krOERncGZEd3ZkR1Y0ZEQ0OEwzTjJaejQ9Iiwic2l6ZXMiOiIxMjh4MTI4IiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifV19">
    <title>Smart Random Generator Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-card: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
            --accent: #6366f1;
            --accent-hover: #4f46e5;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #3b82f6;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-card: #242424;
            --text-primary: #f5f5f5;
            --text-secondary: #a0a0a0;
            --border-color: #3d3d3d;
            --accent: #818cf8;
            --accent-hover: #6366f1;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        [data-theme="purple"] {
            --accent: #a855f7;
            --accent-hover: #9333ea;
        }

        [data-theme="green"] {
            --accent: #10b981;
            --accent-hover: #059669;
        }

        [data-theme="red"] {
            --accent: #ef4444;
            --accent-hover: #dc2626;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background 0.3s, color 0.3s;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .app-layout {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .main-content {
            flex: 1;
            overflow-y: auto;
            position: relative;
            margin-right: 0;
            transition: margin-right 0.3s ease;
        }

        .main-content.sidebar-open {
            margin-right: 320px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
        }

        h1 {
            font-size: 28px;
            font-weight: 700;
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--border-color);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .btn-info {
            background: var(--info);
            color: white;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 13px;
        }

        .theme-toggle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: var(--bg-secondary);
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
        }

        .theme-toggle:hover {
            background: var(--border-color);
            transform: scale(1.05);
        }

        .card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px var(--shadow);
            border: 1px solid var(--border-color);
        }

        .search-filter-bar {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .search-input {
            flex: 1;
            min-width: 200px;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .filter-dropdown {
            padding: 10px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
        }

        .table-list {
            display: grid;
            gap: 16px;
        }

        .table-item {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .table-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .table-item.favorited {
            border-color: var(--warning);
        }

        .favorite-star {
            position: absolute;
            top: 16px;
            right: 16px;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
        }

        .table-item h3 {
            font-size: 18px;
            margin-bottom: 6px;
            padding-right: 40px;
        }

        .table-item p {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 12px;
        }

        .table-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .tag {
            padding: 4px 10px;
            background: var(--accent);
            color: white;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .table-item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .table-item-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 14px;
        }

        .input-group small {
            display: block;
            color: var(--text-secondary);
            margin-top: 4px;
            font-size: 12px;
        }

        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: inherit;
        }

        input[type="number"] {
            width: 80px;
        }

        textarea {
            min-height: 80px;
            resize: vertical;
        }

        .entries-list {
            margin-top: 20px;
        }

        .entry-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .entry-item input[type="text"] {
            flex: 1;
            background: var(--bg-card);
        }

        .entry-item input[type="number"] {
            width: 70px;
        }

        .entry-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }

        .roll-result {
            background: linear-gradient(135deg, var(--accent), var(--accent-hover));
            color: white;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            margin: 20px 0;
            animation: slideIn 0.3s ease-out;
            position: relative;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .shake {
            animation: shake 0.5s;
        }

        .roll-result h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .roll-result p {
            font-size: 18px;
            opacity: 0.9;
        }

        .roll-result.rare {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.5);
        }

        .dice-roller {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin: 20px 0;
        }

        .dice-btn {
            padding: 12px 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dice-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .roll-history {
            max-height: 300px;
            overflow-y: auto;
        }

        .history-item {
            padding: 12px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-time {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--bg-secondary);
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            color: var(--accent);
        }

        .stat-label {
            font-size: 14px;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state h2 {
            font-size: 24px;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: 12px;
            max-width: 700px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .modal-header h2 {
            font-size: 24px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: var(--text-secondary);
            line-height: 1;
        }

        .action-bar {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            background: var(--accent);
            color: white;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 8px;
        }

        .badge.pro {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        .tabs {
            display: flex;
            gap: 8px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 20px;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s;
        }

        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .multi-select-bar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px 24px;
            box-shadow: 0 4px 20px var(--shadow);
            display: none;
            gap: 12px;
            align-items: center;
            z-index: 100;
        }

        .multi-select-bar.active {
            display: flex;
        }

        .hidden {
            display: none;
        }

        @media print {
            body {
                background: white;
                color: black;
            }
            .no-print {
                display: none !important;
            }
            .card {
                box-shadow: none;
                border: 1px solid #ddd;
                page-break-inside: avoid;
            }
        }

        @media (max-width: 640px) {
            .container {
                padding: 12px;
            }

            h1 {
                font-size: 22px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 13px;
            }

            .card {
                padding: 16px;
            }

            .table-item-actions {
                width: 100%;
            }

            .search-filter-bar {
                flex-direction: column;
            }

            .multi-select-bar {
                bottom: 10px;
                left: 10px;
                right: 10px;
                transform: none;
                flex-wrap: wrap;
            }

            .history-sidebar {
                position: fixed;
                right: 0;
                top: 0;
                height: 100%;
                z-index: 999;
                box-shadow: -4px 0 12px var(--shadow);
            }

            .history-toggle.sidebar-open {
                right: 320px;
            }

            .app-layout {
                flex-direction: column;
            }
        }

        /* Confetti animation */
        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: var(--accent);
            pointer-events: none;
            z-index: 9999;
            animation: confetti-fall 3s linear forwards;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 4px 12px var(--shadow);
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
            max-width: 400px;
            animation: slideInRight 0.3s ease-out;
            pointer-events: auto;
            position: relative;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }

        .toast.info {
            border-left: 4px solid var(--info);
        }

        .toast.warning {
            border-left: 4px solid var(--warning);
        }

        .toast-icon {
            font-size: 24px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .toast-message {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 20px;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .toast-close:hover {
            background: var(--bg-secondary);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        .toast.removing {
            animation: slideOutRight 0.3s ease-out forwards;
        }

        /* Drag & Drop */
        .draggable {
            cursor: move;
            transition: all 0.2s;
        }

        .draggable:hover {
            transform: scale(1.02);
        }

        .dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .drag-over {
            border: 2px dashed var(--accent) !important;
            background: var(--bg-secondary) !important;
        }

        .drag-handle {
            cursor: grab;
            padding: 4px;
            color: var(--text-secondary);
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .drag-handle:hover {
            opacity: 1;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            color: var(--text-secondary);
            transition: all 0.2s;
            margin: 20px 0;
        }

        .drop-zone.drag-over {
            border-color: var(--accent);
            background: var(--bg-secondary);
            color: var(--accent);
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        /* Roll Chains */
        .chain-config {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-top: 8px;
        }

        .chain-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding: 8px;
            background: var(--bg-card);
            border-radius: 6px;
        }

        .chain-arrow {
            color: var(--accent);
            font-weight: bold;
            font-size: 16px;
        }

        .chain-result {
            margin-left: 20px;
            padding-left: 20px;
            border-left: 3px solid var(--accent);
            margin-top: 12px;
        }

        .chain-result-item {
            padding: 12px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .chain-result-label {
            font-size: 12px;
            color: var(--accent);
            font-weight: 600;
            margin-bottom: 4px;
        }

        .badge.chain {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
        }

        /* History Sidebar */
        .history-sidebar {
            width: 320px;
            background: var(--bg-card);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            z-index: 500;
            box-shadow: -4px 0 12px var(--shadow);
        }

        .history-sidebar.collapsed {
            transform: translateX(320px);
        }

        .history-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
        }

        .history-header h3 {
            font-size: 16px;
            font-weight: 600;
        }

        .history-list {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .history-entry {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }

        .history-entry:hover {
            transform: translateX(-4px);
            box-shadow: 0 2px 8px var(--shadow);
        }

        .history-entry.pinned {
            border-color: var(--warning);
            background: linear-gradient(to right, var(--warning), var(--bg-secondary) 20%);
        }

        .history-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 8px;
        }

        .history-entry-title {
            font-weight: 600;
            font-size: 13px;
            flex: 1;
            padding-right: 8px;
        }

        .history-entry-time {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .history-entry-result {
            font-size: 13px;
            color: var(--text-primary);
            margin-bottom: 8px;
            line-height: 1.4;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .history-entry-actions {
            display: flex;
            gap: 6px;
        }

        .pin-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            padding: 4px;
            opacity: 0.5;
            transition: opacity 0.2s;
        }

        .pin-btn:hover,
        .history-entry.pinned .pin-btn {
            opacity: 1;
        }

        .history-toggle {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            background: var(--accent);
            color: white;
            border: none;
            padding: 12px 8px;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            font-size: 18px;
            z-index: 501;
            transition: all 0.2s;
            box-shadow: -2px 0 8px var(--shadow);
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .history-toggle:hover {
            padding-right: 12px;
        }

        .history-toggle.sidebar-open {
            right: 320px;
        }

        .history-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .history-footer {
            padding: 12px;
            border-top: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <div class="app-layout">
        <div class="main-content">
            <div class="container">
        <header class="no-print">
            <h1>üé≤ Smart Random Generator <span class="badge pro">PRO</span></h1>
            <div class="header-controls">
                <button class="theme-toggle" id="themeToggle">üåô</button>
                <button class="btn btn-primary" id="createTableBtn">+ New Table</button>
            </div>
        </header>

        <div id="homeView">
            <div class="card no-print">
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('tables')">üìã Tables</button>
                    <button class="tab" onclick="switchTab('history')">üìú History</button>
                    <button class="tab" onclick="switchTab('stats')">üìä Stats</button>
                </div>

                <div id="tabContent"></div>
            </div>

            <div id="searchFilterSection" class="no-print">
                <div class="search-filter-bar">
                    <input type="text" class="search-input" id="searchInput" placeholder="üîç Search tables...">
                    <select class="filter-dropdown" id="filterSort">
                        <option value="date">Sort: Newest</option>
                        <option value="name">Sort: A-Z</option>
                        <option value="rolls">Sort: Most Used</option>
                        <option value="entries">Sort: Entry Count</option>
                    </select>
                    <select class="filter-dropdown" id="filterType">
                        <option value="all">All Types</option>
                        <option value="weighted">Weighted Only</option>
                        <option value="unweighted">Unweighted Only</option>
                        <option value="favorited">Favorites ‚≠ê</option>
                    </select>
                    <select class="filter-dropdown" id="filterTag">
                        <option value="all">All Tags</option>
                    </select>
                </div>
            </div>

            <div id="tablesList" class="table-list"></div>
        </div>

        <div id="tableView" class="hidden"></div>

        <div id="diceView" class="hidden">
            <button class="btn btn-secondary no-print" onclick="goHome()" style="margin-bottom: 20px;">‚Üê Back</button>
            
            <div class="card">
                <h2>üé≤ Dice Roller</h2>
                <p style="color: var(--text-secondary); margin-bottom: 20px;">Roll standard RPG dice</p>
                
                <div class="dice-roller">
                    <button class="dice-btn" onclick="rollDice(4)">d4</button>
                    <button class="dice-btn" onclick="rollDice(6)">d6</button>
                    <button class="dice-btn" onclick="rollDice(8)">d8</button>
                    <button class="dice-btn" onclick="rollDice(10)">d10</button>
                    <button class="dice-btn" onclick="rollDice(12)">d12</button>
                    <button class="dice-btn" onclick="rollDice(20)">d20</button>
                    <button class="dice-btn" onclick="rollDice(100)">d100</button>
                </div>

                <div class="input-group">
                    <label>Custom Dice Formula</label>
                    <input type="text" id="customDice" placeholder="e.g., 2d6+3, 1d20-1, 3d8">
                    <small>Format: [number]d[sides][+/-modifier]</small>
                </div>
                <button class="btn btn-primary" onclick="rollCustomDice()">Roll Custom</button>
            </div>

            <div id="diceResults"></div>
        </div>
    </div>

    <!-- History Toggle Button -->
    <button class="history-toggle no-print" id="historyToggle" onclick="toggleHistorySidebar()">
        üìú
    </button>

    <!-- History Sidebar -->
    <div class="history-sidebar no-print" id="historySidebar">
        <div class="history-header">
            <h3>üìú Roll History</h3>
            <button class="btn btn-secondary btn-sm" onclick="clearAllHistory()">Clear</button>
        </div>
        <div class="history-list" id="historyListSidebar">
            <!-- Dynamically populated -->
        </div>
        <div class="history-footer">
            <small style="color: var(--text-secondary); display: block; text-align: center;">
                Last 20 rolls ‚Ä¢ Click to reroll
            </small>
        </div>
    </div>
</div>

    <!-- Multi-select bar -->
    <div id="multiSelectBar" class="multi-select-bar">
        <span id="selectedCount">0 selected</span>
        <button class="btn btn-secondary btn-sm" onclick="bulkEdit()">Edit Weights</button>
        <button class="btn btn-secondary btn-sm" onclick="mergeTables()">Merge Tables</button>
        <button class="btn btn-danger btn-sm" onclick="bulkDelete()">Delete</button>
        <button class="btn btn-secondary btn-sm" onclick="clearSelection()">Cancel</button>
    </div>

    <!-- Table Modal -->
    <div id="tableModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Create New Table</h2>
                <button class="close-btn" id="closeModal">&times;</button>
            </div>
            <div class="input-group">
                <label>Table Name</label>
                <input type="text" id="tableName" placeholder="e.g., Fantasy Encounters">
            </div>
            <div class="input-group">
                <label>Description</label>
                <textarea id="tableDesc" placeholder="Describe what this table is for..."></textarea>
            </div>
            <div class="input-group">
                <label>Tags (comma-separated)</label>
                <input type="text" id="tableTags" placeholder="e.g., combat, loot, npcs">
                <small>Organize your tables with tags</small>
            </div>
            <div class="input-group">
                <label>Color Theme</label>
                <select id="tableColor">
                    <option value="default">Default (Blue)</option>
                    <option value="purple">Purple</option>
                    <option value="green">Green</option>
                    <option value="red">Red</option>
                    <option value="orange">Orange</option>
                </select>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="useWeights">
                <label for="useWeights" style="margin: 0;">Use weighted entries<span class="badge pro">PRO</span></label>
            </div>
            <div class="input-group">
                <label>Entries</label>
                <div id="entriesList" class="entries-list"></div>
                <button class="btn btn-secondary btn-sm" id="addEntryBtn" style="margin-top: 12px;">+ Add Entry</button>
            </div>

            <div class="input-group">
                <label>Roll Chains<span class="badge chain">PRO</span></label>
                <small>Configure which tables to roll automatically after specific entries</small>
                <div id="chainConfigurator" style="margin-top: 12px;">
                    <!-- Dynamically populated -->
                </div>
            </div>

            <div class="action-bar">
                <button class="btn btn-primary" id="saveTableBtn">Save Table</button>
                <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Multi-table roll modal -->
    <div id="multiRollModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Multi-Table Roll</h2>
                <button class="close-btn" onclick="closeMultiRollModal()">&times;</button>
            </div>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">Select tables to roll together (results shown separately)</p>
            <div id="multiRollList"></div>
            <div class="action-bar">
                <button class="btn btn-primary" onclick="executeMultiRoll()">üé≤ Roll All</button>
                <button class="btn btn-secondary" onclick="closeMultiRollModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Combo Builder modal -->
    <div id="comboBuilderModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="comboModalTitle">Combo Builder</h2>
                <button class="btn btn-info btn-sm" onclick="showComboHelp()" style="margin-right: auto; margin-left: 16px;">‚ùì Help</button>
                <button class="close-btn" onclick="closeComboBuilder()">&times;</button>
            </div>
            
            <div class="tabs" style="margin-bottom: 20px;">
                <button class="tab active" onclick="switchComboTab('create')">Create Combo</button>
                <button class="tab" onclick="switchComboTab('saved')">Saved Combos</button>
            </div>

            <div id="comboCreateTab">
                <div class="input-group">
                    <label>Combo Name</label>
                    <input type="text" id="comboName" placeholder="e.g., Random Encounter">
                </div>

                <div class="input-group">
                    <label>Template<span class="badge pro">PRO</span></label>
                    <textarea id="comboTemplate" placeholder="e.g., {0} appears at {1} carrying {2}" rows="3"></textarea>
                    <small>Use {0}, {1}, {2}, etc. as placeholders for table results</small>
                </div>

                <div class="input-group">
                    <label>Table Assignments</label>
                    <div id="comboTableSlots" style="display: grid; gap: 12px;">
                        <!-- Dynamically populated -->
                    </div>
                    <button class="btn btn-secondary btn-sm" onclick="addComboSlot()" style="margin-top: 12px;">+ Add Table Slot</button>
                </div>

                <div class="input-group">
                    <label>Preview</label>
                    <div id="comboPreview" style="padding: 16px; background: var(--bg-secondary); border-radius: 8px; min-height: 60px; color: var(--text-secondary);">
                        Template preview will appear here...
                    </div>
                    <button class="btn btn-secondary btn-sm" onclick="previewCombo()" style="margin-top: 8px;">Generate Preview</button>
                </div>

                <div class="action-bar">
                    <button class="btn btn-primary" id="rollComboBtn" onclick="rollCombo()">üé≤ Roll Combo</button>
                    <button class="btn btn-success" onclick="saveCombo()">üíæ Save Template</button>
                    <button class="btn btn-secondary" onclick="closeComboBuilder()">Cancel</button>
                </div>
            </div>

            <div id="comboSavedTab" class="hidden">
                <div style="margin-bottom: 16px;">
                    <div class="action-bar">
                        <button class="btn btn-secondary btn-sm" onclick="importCombos()">üì• Import Combos</button>
                        <button class="btn btn-secondary btn-sm" onclick="exportAllCombos()">üì¶ Export All</button>
                    </div>
                </div>
                <div id="savedCombosList"></div>
            </div>
        </div>
    </div>

    <!-- Merge Tables modal -->
    <div id="mergeTablesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Merge Tables</h2>
                <button class="close-btn" onclick="closeMergeModal()">&times;</button>
            </div>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">Select 2 or more tables to combine into one new table</p>
            
            <div id="mergeTablesList" style="max-height: 300px; overflow-y: auto; margin-bottom: 20px;">
                <!-- Dynamically populated -->
            </div>

            <div class="input-group">
                <label>Name for Merged Table</label>
                <input type="text" id="mergedTableName" placeholder="e.g., Combined Encounters">
            </div>

            <div class="action-bar">
                <button class="btn btn-primary" onclick="executeMerge()">üîó Merge Selected</button>
                <button class="btn btn-secondary" onclick="closeMergeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Help/Tutorial modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Combo Builder Guide</h2>
                <button class="close-btn" onclick="closeHelpModal()">&times;</button>
            </div>

            <div style="line-height: 1.8;">
                <h3 style="margin-bottom: 12px;">üìù How to Create Combos</h3>
                <p style="margin-bottom: 16px;">Combo Builder lets you create formatted outputs by combining multiple table results into a single sentence or phrase.</p>

                <h4 style="margin-top: 24px; margin-bottom: 8px;">1Ô∏è‚É£ Write a Template</h4>
                <p style="margin-bottom: 8px;">Use placeholders like {0}, {1}, {2} where you want table results to appear:</p>
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px; font-family: monospace;">
                    {0} appears at {1} carrying {2}
                </div>

                <h4 style="margin-top: 24px; margin-bottom: 8px;">2Ô∏è‚É£ Assign Tables</h4>
                <p style="margin-bottom: 16px;">Select which table fills each placeholder:</p>
                <ul style="margin-left: 20px; margin-bottom: 16px;">
                    <li><strong>{0}</strong> ‚Üí Monster Names table</li>
                    <li><strong>{1}</strong> ‚Üí Locations table</li>
                    <li><strong>{2}</strong> ‚Üí Items table</li>
                </ul>

                <h4 style="margin-top: 24px; margin-bottom: 8px;">3Ô∏è‚É£ Preview & Roll</h4>
                <p style="margin-bottom: 8px;">Click "Generate Preview" to see a sample, then "Roll Combo" for the final result!</p>
                <div style="background: var(--success); color: white; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    ‚ú® Result: "Goblin appears at Dark Forest carrying Magic Sword"
                </div>

                <h4 style="margin-top: 24px; margin-bottom: 8px;">üí° Pro Tips</h4>
                <ul style="margin-left: 20px; margin-bottom: 16px;">
                    <li>Use dice formulas: "Deal {2d6+3} damage"</li>
                    <li>Save templates for frequently used combos</li>
                    <li>You can use the same table multiple times</li>
                    <li>Placeholders can appear multiple times in template</li>
                </ul>

                <h4 style="margin-top: 24px; margin-bottom: 8px;">üìö Example Templates</h4>
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 8px; font-family: monospace; font-size: 13px;">
                    NPC: "{0} is {1} and wants {2}"
                </div>
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 8px; font-family: monospace; font-size: 13px;">
                    Quest: "Help {0} defeat {1} in {2}"
                </div>
                <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 16px; font-family: monospace; font-size: 13px;">
                    Loot: "Find {0} and {1} worth {2} gold"
                </div>

                <button class="btn btn-primary" onclick="closeHelpModal()" style="width: 100%; margin-top: 20px;">Got it!</button>
            </div>
        </div>
    </div>

    <!-- Table Packs Modal -->
    <div id="tablePacksModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìö Community Table Packs</h2>
                <button class="close-btn" onclick="closeTablePacks()">&times;</button>
            </div>
            
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                Professional, ready-to-use table collections for different genres. Import entire packs instantly!
            </p>

            <div id="tablePacksList"></div>
        </div>
    </div>

    <!-- Pack Preview Modal -->
    <div id="packPreviewModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="previewPackTitle">Pack Preview</h2>
                <button class="close-btn" onclick="closePackPreview()">&times;</button>
            </div>
            
            <div id="packPreviewContent"></div>
            
            <div class="action-bar">
                <button class="btn btn-primary" id="importPackBtn">Import This Pack</button>
                <button class="btn btn-secondary" onclick="closePackPreview()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Quick Combos Modal -->
    <div id="quickCombosModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>‚ö° Quick Combos</h2>
                <button class="close-btn" onclick="closeQuickCombos()">&times;</button>
            </div>
            
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                Roll your saved combo templates with one click!
            </p>

            <div id="quickCombosList"></div>
        </div>
    </div>

    <script>
        // Data management
        let tables = [];
        let currentTable = null;
        let editingTableId = null;
        let useWeights = false;
        let rollHistory = [];
        let selectedTables = new Set();
        let currentFilter = {
            search: '',
            sort: 'date',
            type: 'all',
            tag: 'all'
        };
        let savedCombos = [];
        let editingComboId = null;
        let historySidebarOpen = true;
        let pinnedRolls = new Set();
        let draggedElement = null;
        let draggedIndex = null;

        // Community Table Packs
        const tablePacks = {
            fantasy_starter: {
                name: "Fantasy Starter Pack",
                description: "Essential tables for fantasy campaigns with chains configured",
                icon: "üó°Ô∏è",
                author: "Smart Random Generator",
                tags: ["fantasy", "beginner", "d&d", "pathfinder"],
                tables: [
                    {
                        name: "Random Encounters",
                        description: "Common fantasy encounters with automatic detail generation",
                        tags: ["combat", "exploration"],
                        weighted: true,
                        entries: [
                            { text: "Goblin war party", weight: 8, chains: [] },
                            { text: "Wandering merchant", weight: 10, chains: [] },
                            { text: "Ancient dragon", weight: 1, chains: [] },
                            { text: "Bandit ambush", weight: 7, chains: [] },
                            { text: "Friendly travelers", weight: 9, chains: [] },
                            { text: "Wild beasts", weight: 8, chains: [] },
                            { text: "Mysterious hermit", weight: 5, chains: [] },
                            { text: "Undead patrol", weight: 4, chains: [] }
                        ]
                    },
                    {
                        name: "NPC Names",
                        description: "Fantasy character names",
                        tags: ["npcs", "names"],
                        weighted: false,
                        entries: [
                            { text: "Aldric Stormwind", weight: 1, chains: [] },
                            { text: "Elara Moonwhisper", weight: 1, chains: [] },
                            { text: "Thorin Ironforge", weight: 1, chains: [] },
                            { text: "Lysandra Nightshade", weight: 1, chains: [] },
                            { text: "Gareth the Bold", weight: 1, chains: [] },
                            { text: "Mira Silverleaf", weight: 1, chains: [] },
                            { text: "Rowan Blackthorn", weight: 1, chains: [] },
                            { text: "Seraphina Goldenheart", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "NPC Personality",
                        description: "Character personality traits",
                        tags: ["npcs", "roleplay"],
                        weighted: false,
                        entries: [
                            { text: "Brave and honorable", weight: 1, chains: [] },
                            { text: "Cunning and suspicious", weight: 1, chains: [] },
                            { text: "Cheerful and optimistic", weight: 1, chains: [] },
                            { text: "Greedy and selfish", weight: 1, chains: [] },
                            { text: "Wise and patient", weight: 1, chains: [] },
                            { text: "Hot-tempered and rash", weight: 1, chains: [] },
                            { text: "Mysterious and secretive", weight: 1, chains: [] },
                            { text: "Friendly and helpful", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Treasure Hoard",
                        description: "Loot with rarity weighting",
                        tags: ["loot", "treasure"],
                        weighted: true,
                        entries: [
                            { text: "{3d6*10} gold coins", weight: 10, chains: [] },
                            { text: "Healing potion (restores {2d8+2} HP)", weight: 8, chains: [] },
                            { text: "Masterwork weapon (+1)", weight: 5, chains: [] },
                            { text: "Rare gemstone worth {1d6*100} gold", weight: 6, chains: [] },
                            { text: "Magic ring with minor enchantment", weight: 3, chains: [] },
                            { text: "Ancient spellbook (3 random spells)", weight: 4, chains: [] },
                            { text: "Legendary artifact", weight: 1, chains: [] },
                            { text: "Set of thieves' tools", weight: 7, chains: [] }
                        ]
                    },
                    {
                        name: "Quest Hooks",
                        description: "Adventure seeds for your campaign",
                        tags: ["story", "quests"],
                        weighted: false,
                        entries: [
                            { text: "A local noble has gone missing", weight: 1, chains: [] },
                            { text: "Strange lights appear in the forest", weight: 1, chains: [] },
                            { text: "A cursed artifact must be destroyed", weight: 1, chains: [] },
                            { text: "Bandits are terrorizing the trade routes", weight: 1, chains: [] },
                            { text: "An ancient evil is awakening", weight: 1, chains: [] },
                            { text: "The town well has been poisoned", weight: 1, chains: [] },
                            { text: "A dragon demands tribute", weight: 1, chains: [] },
                            { text: "Children are disappearing at night", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Tavern Names",
                        description: "Memorable inn and tavern names",
                        tags: ["locations", "taverns"],
                        weighted: false,
                        entries: [
                            { text: "The Prancing Pony", weight: 1, chains: [] },
                            { text: "The Dragon's Breath Inn", weight: 1, chains: [] },
                            { text: "The Rusty Dagger Tavern", weight: 1, chains: [] },
                            { text: "The Sleeping Giant", weight: 1, chains: [] },
                            { text: "The Golden Goblet", weight: 1, chains: [] },
                            { text: "The Wandering Minstrel", weight: 1, chains: [] },
                            { text: "The Silver Stag Lodge", weight: 1, chains: [] },
                            { text: "The Broken Shield Alehouse", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Magic Items (Minor)",
                        description: "Common magical items",
                        tags: ["loot", "magic"],
                        weighted: true,
                        entries: [
                            { text: "Everburning torch (never goes out)", weight: 8, chains: [] },
                            { text: "Bag of holding (holds 500 lbs)", weight: 5, chains: [] },
                            { text: "Cloak of elvenkind (+2 to stealth)", weight: 6, chains: [] },
                            { text: "Rope of climbing (commands itself)", weight: 7, chains: [] },
                            { text: "Ring of feather falling", weight: 6, chains: [] },
                            { text: "Immovable rod", weight: 4, chains: [] },
                            { text: "Sending stones (pair)", weight: 5, chains: [] },
                            { text: "Goggles of night vision", weight: 7, chains: [] }
                        ]
                    },
                    {
                        name: "Dungeon Rooms",
                        description: "Room contents and features",
                        tags: ["dungeons", "exploration"],
                        weighted: false,
                        entries: [
                            { text: "Empty room with ancient murals", weight: 1, chains: [] },
                            { text: "Guard room with sleeping monsters", weight: 1, chains: [] },
                            { text: "Treasure chamber (trapped)", weight: 1, chains: [] },
                            { text: "Collapsed hallway (difficult terrain)", weight: 1, chains: [] },
                            { text: "Laboratory with strange equipment", weight: 1, chains: [] },
                            { text: "Prison cells with captives", weight: 1, chains: [] },
                            { text: "Library with forbidden knowledge", weight: 1, chains: [] },
                            { text: "Shrine to a dark deity", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Weather Effects",
                        description: "Environmental conditions",
                        tags: ["weather", "environment"],
                        weighted: true,
                        entries: [
                            { text: "Clear skies and pleasant", weight: 12, chains: [] },
                            { text: "Light rain", weight: 10, chains: [] },
                            { text: "Heavy rain (disadvantage on perception)", weight: 6, chains: [] },
                            { text: "Fog (visibility limited to 30 feet)", weight: 7, chains: [] },
                            { text: "Strong winds", weight: 8, chains: [] },
                            { text: "Snow storm", weight: 4, chains: [] },
                            { text: "Extreme heat", weight: 5, chains: [] },
                            { text: "Magical anomaly (roll on wild magic)", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Trap Types",
                        description: "Common dungeon traps",
                        tags: ["dungeons", "traps"],
                        weighted: false,
                        entries: [
                            { text: "Poison dart trap (DC 15 Dex, {2d8} poison)", weight: 1, chains: [] },
                            { text: "Pit trap 20ft deep ({2d6} falling damage)", weight: 1, chains: [] },
                            { text: "Swinging blade (DC 13 Dex, {3d10} slashing)", weight: 1, chains: [] },
                            { text: "Magical alarm (alerts nearby enemies)", weight: 1, chains: [] },
                            { text: "Gas trap (sleeping gas, DC 14 Con save)", weight: 1, chains: [] },
                            { text: "Collapsing ceiling ({4d10} bludgeoning)", weight: 1, chains: [] },
                            { text: "Teleportation circle (random location)", weight: 1, chains: [] },
                            { text: "Cursed item (remove curse needed)", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Rumor & Gossip",
                        description: "Information NPCs might share",
                        tags: ["story", "npcs"],
                        weighted: false,
                        entries: [
                            { text: "The old mill is haunted at night", weight: 1, chains: [] },
                            { text: "Bandits have a hideout in the eastern hills", weight: 1, chains: [] },
                            { text: "The mayor is embezzling town funds", weight: 1, chains: [] },
                            { text: "A treasure map was recently stolen", weight: 1, chains: [] },
                            { text: "Strange creatures seen near the river", weight: 1, chains: [] },
                            { text: "The merchant guild is planning something", weight: 1, chains: [] },
                            { text: "An ancient tomb was recently discovered", weight: 1, chains: [] },
                            { text: "The baron's daughter is secretly a mage", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Settlement Names",
                        description: "Towns, villages, and cities",
                        tags: ["locations", "settlements"],
                        weighted: false,
                        entries: [
                            { text: "Riverbend", weight: 1, chains: [] },
                            { text: "Stonekeep", weight: 1, chains: [] },
                            { text: "Willowdale", weight: 1, chains: [] },
                            { text: "Ironforge", weight: 1, chains: [] },
                            { text: "Shadowmere", weight: 1, chains: [] },
                            { text: "Brighthollow", weight: 1, chains: [] },
                            { text: "Thornwood", weight: 1, chains: [] },
                            { text: "Silverport", weight: 1, chains: [] }
                        ]
                    }
                ]
            },
            dnd_essentials: {
                name: "D&D 5e Essentials",
                description: "Official SRD content and common D&D tables",
                icon: "üêâ",
                author: "Smart Random Generator",
                tags: ["d&d", "5e", "official"],
                tables: [
                    {
                        name: "Trinkets (PHB)",
                        description: "Small wondrous items from Player's Handbook",
                        tags: ["loot", "flavor"],
                        weighted: false,
                        entries: [
                            { text: "A mummified goblin hand", weight: 1, chains: [] },
                            { text: "A crystal orb filled with moving smoke", weight: 1, chains: [] },
                            { text: "A gold coin minted in an unknown land", weight: 1, chains: [] },
                            { text: "A diary written in a language you don't know", weight: 1, chains: [] },
                            { text: "A brass ring that never tarnishes", weight: 1, chains: [] },
                            { text: "An old chess piece made from glass", weight: 1, chains: [] },
                            { text: "A pair of knucklebone dice", weight: 1, chains: [] },
                            { text: "A small idol depicting a nightmarish creature", weight: 1, chains: [] },
                            { text: "A necklace made of small pink pearls", weight: 1, chains: [] },
                            { text: "A broken blade from a dagger", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Potion Effects",
                        description: "Random potion identification",
                        tags: ["magic", "potions"],
                        weighted: true,
                        entries: [
                            { text: "Healing: Restore {2d4+2} HP", weight: 12, chains: [] },
                            { text: "Greater Healing: Restore {4d4+4} HP", weight: 6, chains: [] },
                            { text: "Invisibility: 1 hour duration", weight: 4, chains: [] },
                            { text: "Speed: Double movement for 1 minute", weight: 5, chains: [] },
                            { text: "Resistance: Resistance to one damage type for 1 hour", weight: 5, chains: [] },
                            { text: "Poison: {3d6} poison damage, DC 13 Con save", weight: 3, chains: [] },
                            { text: "Giant Strength: Strength becomes 21 for 1 hour", weight: 3, chains: [] },
                            { text: "Gaseous Form: Turn to mist for 1 hour", weight: 2, chains: [] }
                        ]
                    },
                    {
                        name: "Spell Scroll Levels",
                        description: "Random spell scroll generation",
                        tags: ["magic", "scrolls"],
                        weighted: true,
                        entries: [
                            { text: "Cantrip scroll (any class)", weight: 10, chains: [] },
                            { text: "1st level spell scroll", weight: 12, chains: [] },
                            { text: "2nd level spell scroll", weight: 10, chains: [] },
                            { text: "3rd level spell scroll", weight: 7, chains: [] },
                            { text: "4th level spell scroll", weight: 5, chains: [] },
                            { text: "5th level spell scroll", weight: 3, chains: [] },
                            { text: "6th level spell scroll", weight: 2, chains: [] },
                            { text: "7th+ level spell scroll (rare!)", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Wild Magic Surge",
                        description: "Wild magic effects (simplified)",
                        tags: ["magic", "chaos"],
                        weighted: false,
                        entries: [
                            { text: "Roll {1d20}. On 1, cast Fireball centered on self", weight: 1, chains: [] },
                            { text: "You turn blue for 24 hours", weight: 1, chains: [] },
                            { text: "Teleport 60 feet in random direction", weight: 1, chains: [] },
                            { text: "Grow a long beard (even if female)", weight: 1, chains: [] },
                            { text: "Cast Grease centered on yourself", weight: 1, chains: [] },
                            { text: "Flumph appears next to you for 1 minute", weight: 1, chains: [] },
                            { text: "Regain all expended sorcery points", weight: 1, chains: [] },
                            { text: "You glow bright light for 1 minute", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Critical Hit Effects",
                        description: "Optional critical hit flavor",
                        tags: ["combat", "critical"],
                        weighted: false,
                        entries: [
                            { text: "Target is knocked prone", weight: 1, chains: [] },
                            { text: "Target drops held item", weight: 1, chains: [] },
                            { text: "Target pushed back 10 feet", weight: 1, chains: [] },
                            { text: "Target is blinded until end of your next turn", weight: 1, chains: [] },
                            { text: "Deal an additional {1d6} damage", weight: 1, chains: [] },
                            { text: "Target has disadvantage on next attack", weight: 1, chains: [] },
                            { text: "You gain advantage on next attack against this target", weight: 1, chains: [] },
                            { text: "Target must make DC 13 Con save or be stunned until end of your next turn", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Tavern Events",
                        description: "Things happening at the tavern",
                        tags: ["taverns", "encounters"],
                        weighted: false,
                        entries: [
                            { text: "A bard is performing for tips", weight: 1, chains: [] },
                            { text: "Two patrons start a fist fight", weight: 1, chains: [] },
                            { text: "A mysterious hooded figure watches you", weight: 1, chains: [] },
                            { text: "Someone challenges you to a drinking contest", weight: 1, chains: [] },
                            { text: "A thief attempts to pickpocket party members", weight: 1, chains: [] },
                            { text: "An arm wrestling competition is underway", weight: 1, chains: [] },
                            { text: "The barkeep asks for help with a problem", weight: 1, chains: [] },
                            { text: "A rival adventuring party enters", weight: 1, chains: [] }
                        ]
                    }
                ]
            },
            cyberpunk: {
                name: "Cyberpunk Generator",
                description: "Neon streets, corporate espionage, and high-tech adventures",
                icon: "üåÉ",
                author: "Smart Random Generator",
                tags: ["cyberpunk", "sci-fi", "shadowrun"],
                tables: [
                    {
                        name: "Street Names",
                        description: "Edgerunner aliases and handles",
                        tags: ["npcs", "names"],
                        weighted: false,
                        entries: [
                            { text: "Neon", weight: 1, chains: [] },
                            { text: "Razor", weight: 1, chains: [] },
                            { text: "Ghost", weight: 1, chains: [] },
                            { text: "Chrome", weight: 1, chains: [] },
                            { text: "Viper", weight: 1, chains: [] },
                            { text: "Static", weight: 1, chains: [] },
                            { text: "Glitch", weight: 1, chains: [] },
                            { text: "Blade", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Corp Missions",
                        description: "Corporate jobs and shadowruns",
                        tags: ["quests", "missions"],
                        weighted: false,
                        entries: [
                            { text: "Extract a corporate scientist", weight: 1, chains: [] },
                            { text: "Steal prototype cyberware", weight: 1, chains: [] },
                            { text: "Assassinate a board member", weight: 1, chains: [] },
                            { text: "Hack into rival corp database", weight: 1, chains: [] },
                            { text: "Deliver encrypted package", weight: 1, chains: [] },
                            { text: "Sabotage production facility", weight: 1, chains: [] },
                            { text: "Rescue kidnapped exec", weight: 1, chains: [] },
                            { text: "Plant false evidence", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Cyberware",
                        description: "Augmentations and implants",
                        tags: ["loot", "cyberware"],
                        weighted: true,
                        entries: [
                            { text: "Neural interface port", weight: 8, chains: [] },
                            { text: "Cybereyes with low-light vision", weight: 7, chains: [] },
                            { text: "Dermal plating (+1 AC)", weight: 6, chains: [] },
                            { text: "Retractable blade (1d6 damage)", weight: 5, chains: [] },
                            { text: "Cyberarm with enhanced strength", weight: 4, chains: [] },
                            { text: "Reflex boosters (+2 initiative)", weight: 5, chains: [] },
                            { text: "Cortex bomb (anti-betrayal insurance)", weight: 2, chains: [] },
                            { text: "Military-grade combat rig (rare!)", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "District Events",
                        description: "Street-level happenings",
                        tags: ["encounters", "events"],
                        weighted: false,
                        entries: [
                            { text: "Gang shootout blocks the street", weight: 1, chains: [] },
                            { text: "Corp security checkpoint ahead", weight: 1, chains: [] },
                            { text: "Ripperdoc offering cheap implants", weight: 1, chains: [] },
                            { text: "Netrunner getting flatlined in public", weight: 1, chains: [] },
                            { text: "Protest against corporate oppression", weight: 1, chains: [] },
                            { text: "Black market weapons deal going down", weight: 1, chains: [] },
                            { text: "Fixer has a job opportunity", weight: 1, chains: [] },
                            { text: "Braindance den raided by police", weight: 1, chains: [] }
                        ]
                    },
                    {
                        name: "Vehicle Types",
                        description: "Transportation options",
                        tags: ["vehicles", "equipment"],
                        weighted: true,
                        entries: [
                            { text: "Motorcycle (fast, vulnerable)", weight: 8, chains: [] },
                            { text: "Armored sedan (corporate)", weight: 6, chains: [] },
                            { text: "AV-4 flying car (expensive)", weight: 3, chains: [] },
                            { text: "Cargo truck (spacious)", weight: 7, chains: [] },
                            { text: "Sports coupe (flashy)", weight: 5, chains: [] },
                            { text: "Combat vehicle (military)", weight: 2, chains: [] },
                            { text: "Hoverboard (personal)", weight: 6, chains: [] },
                            { text: "Stolen police cruiser", weight: 1, chains: [] }
                        ]
                    }
                ]
            }
        };

        // Sound effects (simple beep using Web Audio API)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // CRYPTOGRAPHICALLY STRONG RANDOM NUMBER GENERATOR
        // Uses crypto.getRandomValues() for proper entropy
        function getSecureRandom() {
            const array = new Uint32Array(1);
            crypto.getRandomValues(array);
            return array[0] / (0xFFFFFFFF + 1); // Convert to 0-1 range
        }

        function getSecureRandomInt(min, max) {
            // Ensure unbiased distribution using rejection sampling
            const range = max - min;
            const maxAcceptable = Math.floor(0xFFFFFFFF / range) * range;
            
            let randomValue;
            do {
                const array = new Uint32Array(1);
                crypto.getRandomValues(array);
                randomValue = array[0];
            } while (randomValue >= maxAcceptable);
            
            return min + (randomValue % range);
        }

        // Fisher-Yates shuffle for proper randomization
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = getSecureRandomInt(0, i + 1);
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Anti-repetition system: Track recent rolls per table
        const recentRolls = new Map(); // tableId -> array of recent indices
        const RECENT_HISTORY_SIZE = 3; // Avoid repeating last 3 results

        function addToRecentRolls(tableId, index) {
            if (!recentRolls.has(tableId)) {
                recentRolls.set(tableId, []);
            }
            const history = recentRolls.get(tableId);
            history.push(index);
            if (history.length > RECENT_HISTORY_SIZE) {
                history.shift();
            }
        }

        function getAvailableIndices(entries, tableId) {
            const recent = recentRolls.get(tableId) || [];
            
            // If we have enough entries, exclude recent ones
            if (entries.length > RECENT_HISTORY_SIZE + 1) {
                return entries
                    .map((_, idx) => idx)
                    .filter(idx => !recent.includes(idx));
            }
            
            // If table is too small, just return all indices
            return entries.map((_, idx) => idx);
        }
        
        function playSound(frequency = 440, duration = 100) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        function createConfetti() {
            const colors = ['#6366f1', '#f59e0b', '#10b981', '#ef4444', '#3b82f6'];
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                document.body.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 3000);
            }
        }

        // Toast Notification System
        function showToast(message, type = 'info', title = '', duration = 3000) {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '‚úì',
                error: '‚úï',
                info: '‚Ñπ',
                warning: '‚ö†'
            };

            const titles = {
                success: title || 'Success',
                error: title || 'Error',
                info: title || 'Info',
                warning: title || 'Warning'
            };

            toast.innerHTML = `
                <div class="toast-icon">${icons[type]}</div>
                <div class="toast-content">
                    <div class="toast-title">${titles[type]}</div>
                    <div class="toast-message">${message}</div>
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">√ó</button>
            `;

            container.appendChild(toast);

            // Auto-remove after duration
            if (duration > 0) {
                setTimeout(() => {
                    toast.classList.add('removing');
                    setTimeout(() => toast.remove(), 300);
                }, duration);
            }
        }

        // Service Worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('data:text/javascript;base64,c2VsZi5hZGRFdmVudExpc3RlbmVyKCdpbnN0YWxsJywgZSA9PiBlLndhaXRVbnRpbChzZWxmLnNraXBXYWl0aW5nKCkpKTsgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdmZXRjaCcsIGUgPT4gZS5yZXNwb25kV2l0aChmZXRjaChlLnJlcXVlc3QpKSk7')
                .catch(() => {});
        }

        // Default tables with enhanced data
        const defaultTables = [
            {
                id: 'default-1',
                name: 'Fantasy Encounters',
                description: 'Random encounters for fantasy adventures',
                weighted: false,
                tags: ['fantasy', 'combat', 'exploration'],
                color: 'default',
                favorite: false,
                rollCount: 0,
                entries: [
                    { text: 'A wandering merchant with rare goods', weight: 1, chains: [] },
                    { text: 'A pack of wolves blocking the path', weight: 1, chains: [] },
                    { text: 'An ancient shrine with a mysterious guardian', weight: 1, chains: [] },
                    { text: 'A group of bandits demanding tolls', weight: 1, chains: [] },
                    { text: 'A lost child searching for their village', weight: 1, chains: [] },
                    { text: 'A mystical fog that distorts reality', weight: 1, chains: [] },
                    { text: 'A friendly dragon seeking conversation', weight: 1, chains: [] },
                    { text: 'Ruins of an old battlefield', weight: 1, chains: [] }
                ],
                created: Date.now()
            },
            {
                id: 'default-2',
                name: 'Treasure Loot (Weighted)',
                description: 'Random treasure with rarity system',
                weighted: true,
                tags: ['loot', 'treasure', 'fantasy'],
                color: 'orange',
                favorite: false,
                rollCount: 0,
                entries: [
                    { text: 'A pouch of 50 gold coins', weight: 10, chains: [] },
                    { text: 'A mysterious glowing gemstone', weight: 3, chains: [] },
                    { text: 'An ancient map to a hidden location', weight: 5, chains: [] },
                    { text: 'A finely crafted steel dagger', weight: 8, chains: [] },
                    { text: 'A healing potion (restores {2d8+2} HP)', weight: 7, chains: [] },
                    { text: 'A magical ring with unknown properties', weight: 2, chains: [] },
                    { text: 'A set of lockpicks', weight: 6, chains: [] },
                    { text: 'A legendary artifact (ULTRA RARE)', weight: 1, chains: [] }
                ],
                created: Date.now()
            },
            {
                id: 'default-3',
                name: 'NPC Personality Traits',
                description: 'Quick traits to bring NPCs to life',
                weighted: false,
                tags: ['npcs', 'roleplay'],
                color: 'purple',
                favorite: false,
                rollCount: 0,
                entries: [
                    { text: 'Overly optimistic and cheerful', weight: 1, chains: [] },
                    { text: 'Suspicious of strangers', weight: 1, chains: [] },
                    { text: 'Speaks in riddles', weight: 1, chains: [] },
                    { text: 'Has a nervous tick (tapping, humming)', weight: 1, chains: [] },
                    { text: 'Extremely honest, even when inappropriate', weight: 1, chains: [] },
                    { text: 'Obsessed with a particular hobby or collection', weight: 1, chains: [] },
                    { text: 'Always speaks in third person', weight: 1, chains: [] },
                    { text: 'Has a strong accent from a distant land', weight: 1, chains: [] }
                ],
                created: Date.now()
            },
            {
                id: 'default-4',
                name: 'Plot Hooks',
                description: 'Story seeds for your campaign',
                weighted: false,
                tags: ['story', 'plot', 'adventure'],
                color: 'green',
                favorite: false,
                rollCount: 0,
                entries: [
                    { text: 'A local noble has been replaced by a doppelganger', weight: 1, chains: [] },
                    { text: 'Strange lights appear in the forest at night', weight: 1, chains: [] },
                    { text: 'A loved one receives a cryptic message', weight: 1, chains: [] },
                    { text: 'The town well has run dry mysteriously', weight: 1, chains: [] },
                    { text: 'A traveling circus harbors a dark secret', weight: 1, chains: [] },
                    { text: 'Children are disappearing during the full moon', weight: 1, chains: [] },
                    { text: 'An old rival resurfaces with a warning', weight: 1, chains: [] },
                    { text: 'A cursed artifact is discovered in the market', weight: 1, chains: [] }
                ],
                created: Date.now()
            }
        ];

        // Initialize app
        function init() {
            loadTables();
            loadHistory();
            loadCombos();
            loadPinnedRolls();
            loadTheme();
            loadHistorySidebarState();
            setupEventListeners();
            switchTab('tables');
            renderHistorySidebar();
        }

        // Load tables
        function loadTables() {
            const stored = localStorage.getItem('ttrpg_tables');
            if (stored) {
                tables = JSON.parse(stored);
                // Migrate old format
                tables = tables.map(t => {
                    if (!t.tags) t.tags = [];
                    if (!t.color) t.color = 'default';
                    if (t.favorite === undefined) t.favorite = false;
                    if (t.rollCount === undefined) t.rollCount = 0;
                    if (t.entries && typeof t.entries[0] === 'string') {
                        t.entries = t.entries.map(e => ({ text: e, weight: 1 }));
                    }
                    if (t.weighted === undefined) t.weighted = false;
                    return t;
                });
            } else {
                tables = [...defaultTables];
                saveTables();
            }
        }

        function saveTables() {
            localStorage.setItem('ttrpg_tables', JSON.stringify(tables));
        }

        function loadHistory() {
            const stored = localStorage.getItem('roll_history');
            rollHistory = stored ? JSON.parse(stored) : [];
        }

        function saveHistory() {
            localStorage.setItem('roll_history', JSON.stringify(rollHistory.slice(-20))); // Keep last 20
            renderHistorySidebar();
        }

        function loadPinnedRolls() {
            const stored = localStorage.getItem('pinned_rolls');
            pinnedRolls = stored ? new Set(JSON.parse(stored)) : new Set();
        }

        function savePinnedRolls() {
            localStorage.setItem('pinned_rolls', JSON.stringify([...pinnedRolls]));
        }

        function loadCombos() {
            const stored = localStorage.getItem('saved_combos');
            savedCombos = stored ? JSON.parse(stored) : [];
        }

        function saveCombos() {
            localStorage.setItem('saved_combos', JSON.stringify(savedCombos));
        }

        function addToHistory(tableName, result, type = 'table', metadata = null) {
            const entry = {
                id: 'hist-' + Date.now(),
                tableName,
                result,
                type,
                metadata,
                timestamp: Date.now()
            };
            rollHistory.unshift(entry);
            saveHistory();
        }

        // History Sidebar Functions
        function toggleHistorySidebar() {
            historySidebarOpen = !historySidebarOpen;
            const sidebar = document.getElementById('historySidebar');
            const toggle = document.getElementById('historyToggle');
            const mainContent = document.querySelector('.main-content');
            
            if (historySidebarOpen) {
                sidebar.classList.remove('collapsed');
                toggle.classList.add('sidebar-open');
                mainContent.classList.add('sidebar-open');
            } else {
                sidebar.classList.add('collapsed');
                toggle.classList.remove('sidebar-open');
                mainContent.classList.remove('sidebar-open');
            }
            
            localStorage.setItem('history_sidebar_open', historySidebarOpen);
        }

        function loadHistorySidebarState() {
            const stored = localStorage.getItem('history_sidebar_open');
            historySidebarOpen = stored === null ? true : stored === 'true';
            
            const sidebar = document.getElementById('historySidebar');
            const toggle = document.getElementById('historyToggle');
            const mainContent = document.querySelector('.main-content');
            
            if (!historySidebarOpen) {
                sidebar.classList.add('collapsed');
                toggle.classList.remove('sidebar-open');
                mainContent.classList.remove('sidebar-open');
            } else {
                toggle.classList.add('sidebar-open');
                mainContent.classList.add('sidebar-open');
            }
        }

        function renderHistorySidebar() {
            const container = document.getElementById('historyListSidebar');
            
            if (rollHistory.length === 0) {
                container.innerHTML = `
                    <div class="history-empty">
                        <p style="font-size: 40px; margin-bottom: 8px;">üé≤</p>
                        <p>No rolls yet</p>
                        <p style="font-size: 12px; margin-top: 8px;">Roll a table to see history</p>
                    </div>
                `;
                return;
            }

            // Sort: pinned first, then by time
            const sorted = [...rollHistory].sort((a, b) => {
                const aPinned = pinnedRolls.has(a.id);
                const bPinned = pinnedRolls.has(b.id);
                if (aPinned && !bPinned) return -1;
                if (!aPinned && bPinned) return 1;
                return 0; // Maintain original order for same pin status
            });

            container.innerHTML = sorted.map(item => {
                const isPinned = pinnedRolls.has(item.id);
                return `
                    <div class="history-entry ${isPinned ? 'pinned' : ''}" onclick="rerollFromSidebar('${item.id}')">
                        <button class="pin-btn" onclick="event.stopPropagation(); togglePin('${item.id}')" title="${isPinned ? 'Unpin' : 'Pin'}">
                            ${isPinned ? 'üìå' : 'üìç'}
                        </button>
                        <div class="history-entry-header">
                            <div class="history-entry-title">${escapeHtml(item.tableName)}</div>
                            <div class="history-entry-time">${formatTime(item.timestamp)}</div>
                        </div>
                        <div class="history-entry-result">${escapeHtml(item.result)}</div>
                        <div class="history-entry-actions">
                            <button class="btn btn-primary btn-sm" onclick="event.stopPropagation(); rerollFromSidebar('${item.id}')">
                                üé≤ Reroll
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); copyToClipboard('${escapeHtml(item.result)}')">
                                üìã
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function togglePin(historyId) {
            if (pinnedRolls.has(historyId)) {
                pinnedRolls.delete(historyId);
            } else {
                pinnedRolls.add(historyId);
            }
            savePinnedRolls();
            renderHistorySidebar();
        }

        function clearAllHistory() {
            if (!confirm('Clear all roll history? Pinned items will also be removed.')) return;
            rollHistory = [];
            pinnedRolls.clear();
            saveHistory();
            savePinnedRolls();
            renderHistorySidebar();
        }

        function rerollFromSidebar(historyId) {
            const historyItem = rollHistory.find(item => item.id === historyId);
            if (!historyItem) {
                showToast('History item not found', 'error');
                return;
            }

            const { tableName, type, metadata } = historyItem;

            if (type === 'table') {
                const table = tables.find(t => t.name === tableName);
                if (table) {
                    viewTable(table.id);
                    setTimeout(() => rollTable(), 100);
                } else {
                    showToast('Table not found. It may have been deleted.', 'error');
                }
            } else if (type === 'combo') {
                if (metadata && metadata.template && metadata.tableSlots) {
                    rerollComboFromResult(metadata);
                } else {
                    showToast('Cannot reroll this combo (missing metadata)', 'error');
                }
            } else if (type === 'multi-roll') {
                if (metadata && metadata.tableIds) {
                    rerollMultiTableFromHistory(metadata.tableIds);
                } else {
                    showToast('Cannot reroll multi-table (metadata missing)', 'error');
                }
            } else if (type && type.startsWith('d')) {
                const sides = parseInt(type.substring(1));
                showDiceRoller();
                setTimeout(() => rollDice(sides), 100);
            } else {
                showToast('Cannot reroll this type of entry', 'error');
            }
        }

        // Tab switching
        function switchTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event?.target?.classList.add('active');
            
            const content = document.getElementById('tabContent');
            
            if (tab === 'tables') {
                document.getElementById('searchFilterSection').style.display = 'block';
                document.getElementById('tablesList').style.display = 'grid';
                content.innerHTML = `
                    <div class="action-bar">
                        <button class="btn btn-info" onclick="showTablePacks()">üìö Browse Table Packs</button>
                        <button class="btn btn-secondary" onclick="showDiceRoller()">üé≤ Dice Roller</button>
                        <button class="btn btn-secondary" onclick="showMultiRoll()">üéØ Multi-Table Roll</button>
                        <button class="btn btn-info" onclick="showComboBuilder()">‚ú® Combo Builder</button>
                        <button class="btn btn-secondary" onclick="showQuickCombos()">‚ö° Quick Combos</button>
                        <button class="btn btn-success" onclick="showMergeTables()">üîó Merge Tables</button>
                        <button class="btn btn-secondary" onclick="importTables()">üì• Import</button>
                        <button class="btn btn-secondary" onclick="exportAllTables()">üì¶ Export All</button>
                    </div>
                `;
                renderTablesList();
            } else if (tab === 'history') {
                document.getElementById('searchFilterSection').style.display = 'none';
                document.getElementById('tablesList').style.display = 'none';
                renderHistory();
            } else if (tab === 'stats') {
                document.getElementById('searchFilterSection').style.display = 'none';
                document.getElementById('tablesList').style.display = 'none';
                renderStats();
            }
        }

        // Render history (tab view - now supplementary to sidebar)
        function renderHistory() {
            const content = document.getElementById('tabContent');
            
            if (rollHistory.length === 0) {
                content.innerHTML += `
                    <div class="empty-state">
                        <h2>No Roll History</h2>
                        <p>Your recent rolls appear in the sidebar ‚Üí</p>
                    </div>
                `;
                return;
            }

            content.innerHTML = `
                <div style="display: flex; justify-content: space-between; margin-bottom: 16px;">
                    <h3>All Roll History</h3>
                    <button class="btn btn-secondary btn-sm" onclick="exportHistory()">Export History</button>
                </div>
                <div class="roll-history">
                    ${rollHistory.map(item => `
                        <div class="history-item">
                            <div>
                                <strong>${escapeHtml(item.tableName)}</strong>
                                <p style="color: var(--text-secondary); font-size: 14px; margin-top: 4px;">
                                    ${escapeHtml(item.result)}
                                </p>
                            </div>
                            <div style="text-align: right;">
                                <div class="history-time">${formatTime(item.timestamp)}</div>
                                <button class="btn btn-secondary btn-sm" onclick="rerollFromSidebar('${item.id}')" style="margin-top: 4px;">
                                    ‚Üª Roll Again
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function exportHistory() {
            const text = rollHistory.map(item => 
                `${new Date(item.timestamp).toLocaleString()}\n${item.tableName}: ${item.result}\n`
            ).join('\n');
            
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `roll_history_${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function formatTime(timestamp) {
            const diff = Date.now() - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) return `${days}d ago`;
            if (hours > 0) return `${hours}h ago`;
            if (minutes > 0) return `${minutes}m ago`;
            return 'Just now';
        }

        // Render stats
        function renderStats() {
            const content = document.getElementById('tabContent');
            
            const totalRolls = tables.reduce((sum, t) => sum + (t.rollCount || 0), 0);
            const mostUsed = [...tables].sort((a, b) => (b.rollCount || 0) - (a.rollCount || 0))[0];
            const avgEntriesPerTable = Math.round(tables.reduce((sum, t) => sum + t.entries.length, 0) / tables.length);
            
            content.innerHTML = `
                <h3 style="margin-bottom: 20px;">Usage Statistics</h3>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${tables.length}</div>
                        <div class="stat-label">Total Tables</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalRolls}</div>
                        <div class="stat-label">Total Rolls</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${avgEntriesPerTable}</div>
                        <div class="stat-label">Avg Entries/Table</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${tables.filter(t => t.favorite).length}</div>
                        <div class="stat-label">Favorited Tables</div>
                    </div>
                </div>
                
                ${mostUsed ? `
                    <div style="margin-top: 30px;">
                        <h3 style="margin-bottom: 16px;">Most Used Table</h3>
                        <div class="history-item">
                            <div>
                                <strong>${escapeHtml(mostUsed.name)}</strong>
                                <p style="color: var(--text-secondary); font-size: 14px; margin-top: 4px;">
                                    Rolled ${mostUsed.rollCount} times
                                </p>
                            </div>
                            <button class="btn btn-secondary btn-sm" onclick="viewTable('${mostUsed.id}')">View</button>
                        </div>
                    </div>
                ` : ''}
                
                <div style="margin-top: 30px;">
                    <h3 style="margin-bottom: 16px;">All Tables by Usage</h3>
                    <div style="display: grid; gap: 8px;">
                        ${tables.sort((a, b) => (b.rollCount || 0) - (a.rollCount || 0))
                            .map(table => `
                                <div style="display: flex; justify-content: space-between; padding: 12px; background: var(--bg-secondary); border-radius: 8px;">
                                    <span>${escapeHtml(table.name)}</span>
                                    <span style="color: var(--text-secondary);">${table.rollCount || 0} rolls</span>
                                </div>
                            `).join('')}
                    </div>
                </div>
            `;
        }

        // Filter and render tables
        function renderTablesList() {
            const container = document.getElementById('tablesList');
            
            let filtered = tables.filter(table => {
                // Search filter
                if (currentFilter.search) {
                    const search = currentFilter.search.toLowerCase();
                    const matchName = table.name.toLowerCase().includes(search);
                    const matchDesc = (table.description || '').toLowerCase().includes(search);
                    const matchTags = table.tags.some(tag => tag.toLowerCase().includes(search));
                    if (!matchName && !matchDesc && !matchTags) return false;
                }
                
                // Type filter
                if (currentFilter.type === 'weighted' && !table.weighted) return false;
                if (currentFilter.type === 'unweighted' && table.weighted) return false;
                if (currentFilter.type === 'favorited' && !table.favorite) return false;
                
                // Tag filter
                if (currentFilter.tag !== 'all' && !table.tags.includes(currentFilter.tag)) return false;
                
                return true;
            });

            // Sort
            filtered.sort((a, b) => {
                switch (currentFilter.sort) {
                    case 'name': return a.name.localeCompare(b.name);
                    case 'rolls': return (b.rollCount || 0) - (a.rollCount || 0);
                    case 'entries': return b.entries.length - a.entries.length;
                    default: return b.created - a.created;
                }
            });

            if (filtered.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <h2>No Tables Found</h2>
                        <p>Try adjusting your filters or create a new table!</p>
                    </div>
                `;
                return;
            }

            // Update tag filter dropdown
            const allTags = [...new Set(tables.flatMap(t => t.tags))];
            const tagFilter = document.getElementById('filterTag');
            const currentTag = tagFilter.value;
            tagFilter.innerHTML = '<option value="all">All Tags</option>' + 
                allTags.map(tag => `<option value="${tag}">${tag}</option>`).join('');
            tagFilter.value = currentTag;

            container.innerHTML = filtered.map(table => `
                <div class="table-item ${table.favorite ? 'favorited' : ''}" onclick="viewTable('${table.id}')">
                    <span class="favorite-star" onclick="event.stopPropagation(); toggleFavorite('${table.id}')">
                        ${table.favorite ? '‚≠ê' : '‚òÜ'}
                    </span>
                    <h3>${escapeHtml(table.name)}${table.weighted ? '<span class="badge pro">WEIGHTED</span>' : ''}</h3>
                    <p>${escapeHtml(table.description || 'No description')}</p>
                    ${table.tags.length > 0 ? `
                        <div class="table-tags">
                            ${table.tags.map(tag => `<span class="tag">${escapeHtml(tag)}</span>`).join('')}
                        </div>
                    ` : ''}
                    <div class="table-item-meta">
                        <span>${table.entries.length} entries ‚Ä¢ ${table.rollCount || 0} rolls</span>
                        <div class="table-item-actions">
                            <button class="btn btn-primary btn-sm" onclick="event.stopPropagation(); quickRoll('${table.id}')" title="Quick roll this table">
                                üé≤ Roll
                            </button>
                            <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); editTable('${table.id}')">Edit</button>
                            <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); duplicateTable('${table.id}')">Duplicate</button>
                            <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); exportTable('${table.id}')">JSON</button>
                            <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); printTable('${table.id}')">PDF</button>
                            <button class="btn btn-danger btn-sm" onclick="event.stopPropagation(); deleteTable('${table.id}')">Delete</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Toggle favorite
        function toggleFavorite(id) {
            const table = tables.find(t => t.id === id);
            if (table) {
                table.favorite = !table.favorite;
                saveTables();
                renderTablesList();
            }
        }

        // Quick roll from table list - NOW WITH CHAIN SUPPORT
        function quickRoll(id) {
            const table = tables.find(t => t.id === id);
            if (!table || table.entries.length === 0) {
                alert('This table has no entries!');
                return;
            }

            const entry = table.weighted ? 
                rollWeighted(table.entries, table.id) :
                rollUnweighted(table.entries, table.id);
            
            if (!entry) {
                alert('Error rolling table');
                return;
            }
            
            const result = entry.text;
            const processedResult = processDiceInText(result);
            const isRare = table.weighted && entry.weight <= 2;

            // Execute chains
            const chainResults = [];
            if (entry.chains && entry.chains.length > 0) {
                entry.chains.forEach(chainTableId => {
                    const chainTable = tables.find(t => t.id === chainTableId);
                    if (chainTable && chainTable.entries.length > 0) {
                        const chainEntry = chainTable.weighted ?
                            rollWeighted(chainTable.entries, chainTable.id) :
                            rollUnweighted(chainTable.entries, chainTable.id);
                        if (chainEntry) {
                            chainResults.push({
                                tableName: chainTable.name,
                                result: processDiceInText(chainEntry.text)
                            });
                            chainTable.rollCount = (chainTable.rollCount || 0) + 1;
                        }
                    }
                });
                // Save after incrementing chain counts
                if (chainResults.length > 0) {
                    saveTables();
                }
            }

            if (isRare) {
                playSound(880, 150);
                createConfetti();
            } else {
                playSound(440, 150);
            }

            table.rollCount = (table.rollCount || 0) + 1;
            saveTables();
            
            const fullResult = result + (chainResults.length > 0 ? 
                ' ‚Üí ' + chainResults.map(cr => `${cr.tableName}: ${cr.result}`).join(' ‚Üí ') : '');
            addToHistory(table.name, fullResult);

            // Show inline result with chains
            showQuickRollResultWithChains(table.name, processedResult, chainResults, isRare, id);
            renderTablesList();
        }

        function showQuickRollResultWithChains(tableName, result, chainResults, isRare, tableId) {
            const existingResult = document.getElementById('quickRollResult');
            if (existingResult) existingResult.remove();

            const resultDiv = document.createElement('div');
            resultDiv.id = 'quickRollResult';
            resultDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 1001;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            const fullResultText = result.replace(/<[^>]*>/g, '') + 
                (chainResults.length > 0 ? '\n\n' + chainResults.map(cr => `‚Ü≥ ${cr.tableName}: ${cr.result.replace(/<[^>]*>/g, '')}`).join('\n') : '');
            
            resultDiv.innerHTML = `
                <div class="roll-result ${isRare ? 'rare' : ''}" style="animation: slideIn 0.3s ease-out;">
                    <button onclick="closeQuickRollResult()" style="position: absolute; top: 12px; right: 12px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; opacity: 0.8;">&times;</button>
                    <h2>üé≤ ${escapeHtml(tableName)}${isRare ? ' ‚ú®' : ''}</h2>
                    <p style="margin-top: 16px;">${result}</p>
                    ${chainResults.length > 0 ? `
                        <div class="chain-result">
                            ${chainResults.map(cr => `
                                <div class="chain-result-item">
                                    <div class="chain-result-label">‚Ü≥ ${escapeHtml(cr.tableName)}</div>
                                    <div>${cr.result}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    <div class="action-bar" style="justify-content: center; margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="copyToClipboard(\`${escapeHtml(fullResultText)}\`)">üìã Copy All</button>
                        <button class="btn btn-secondary" onclick="closeQuickRollResult(); quickRoll('${tableId}')">‚Üª Reroll</button>
                        <button class="btn btn-primary" onclick="closeQuickRollResult(); viewTable('${tableId}')">View Table</button>
                    </div>
                </div>
            `;

            const backdrop = document.createElement('div');
            backdrop.id = 'quickRollBackdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
            `;
            backdrop.onclick = closeQuickRollResult;

            document.body.appendChild(backdrop);
            document.body.appendChild(resultDiv);
        }

        function rerollComboFromResult(metadata) {
            if (!metadata || !metadata.template || !metadata.tableSlots) {
                showToast('Cannot reroll combo: missing metadata', 'error');
                return;
            }

            let result = metadata.template;
            const usedTables = [];
            const allChainResults = []; // To hold all chain results from all tables in the combo

            metadata.tableSlots.forEach((tableId, index) => {
                if (tableId) {
                    const table = tables.find(t => t.id === tableId);
                    if (table && table.entries.length > 0) {
                        const entry = table.weighted ?
                            rollWeighted(table.entries, table.id) :
                            rollUnweighted(table.entries, table.id);

                        if (entry) {
                            const mainText = entry.text;
                            result = result.replace(new RegExp(`\\{${index}\\}`, 'g'), mainText);
                            usedTables.push(table.name);
                            table.rollCount = (table.rollCount || 0) + 1;

                            // Execute chains for this specific table entry
                            if (entry.chains && entry.chains.length > 0) {
                                entry.chains.forEach(chainTableId => {
                                    const chainTable = tables.find(t => t.id === chainTableId);
                                    if (chainTable && chainTable.entries.length > 0) {
                                        const chainEntry = chainTable.weighted ?
                                            rollWeighted(chainTable.entries, chainTable.id) :
                                            rollUnweighted(chainTable.entries, chainTable.id);
                                        if (chainEntry) {
                                            allChainResults.push({
                                                sourceTable: table.name,
                                                tableName: chainTable.name,
                                                result: processDiceInText(chainEntry.text)
                                            });
                                            chainTable.rollCount = (chainTable.rollCount || 0) + 1;
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
            });

            const processedResult = processDiceInText(result);
            saveTables();
            playSound(440, 150);

            const comboName = metadata.name || 'Unnamed Combo';

            // Construct a full result string for history, including chains
            let fullResultForHistory = result;
            if (allChainResults.length > 0) {
                fullResultForHistory += ' ‚Üí ' + allChainResults.map(cr => `${cr.tableName}: ${cr.result.replace(/<[^>]*>/g, '')}`).join(' ‚Üí ');
            }

            addToHistory('Combo: ' + comboName, fullResultForHistory, 'combo', metadata);

            closeQuickRollResult(); // Close previous result if open
            showComboResultWithReroll(comboName, processedResult, usedTables, metadata, allChainResults);
        }

        function closeQuickRollResult() {
            const result = document.getElementById('quickRollResult');
            const backdrop = document.getElementById('quickRollBackdrop');
            if (result) result.remove();
            if (backdrop) backdrop.remove();
        }

        // View table
        function viewTable(id) {
            currentTable = tables.find(t => t.id === id);
            if (!currentTable) return;

            document.getElementById('homeView').classList.add('hidden');
            document.getElementById('diceView').classList.add('hidden');
            const tableView = document.getElementById('tableView');
            tableView.classList.remove('hidden');

            const weightInfo = currentTable.weighted ? 
                '<p style="color: var(--text-secondary); font-size: 14px; margin-top: 8px;">‚öñÔ∏è This table uses weighted probabilities</p>' : '';

            tableView.innerHTML = `
                <button class="btn btn-secondary no-print" onclick="goHome()" style="margin-bottom: 20px;">‚Üê Back</button>
                
                <div class="card">
                    <h2>${escapeHtml(currentTable.name)}</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 20px;">${escapeHtml(currentTable.description || '')}</p>
                    ${weightInfo}
                    
                    <div class="action-bar no-print">
                        <button class="btn btn-primary" onclick="rollTable()">üé≤ Roll</button>
                        <button class="btn btn-secondary" onclick="rollMultiple(3)">Roll 3x</button>
                        <button class="btn btn-secondary" onclick="rollWithAdvantage()">Roll w/ Advantage</button>
                        <button class="btn btn-secondary" onclick="editTable('${currentTable.id}')">Edit</button>
                        <button class="btn btn-secondary" onclick="duplicateTable('${currentTable.id}')">Duplicate</button>
                        <button class="btn btn-secondary" onclick="exportTable('${currentTable.id}')">JSON</button>
                        <button class="btn btn-warning" onclick="printTable('${currentTable.id}')">PDF</button>
                    </div>
                </div>

                <div id="rollResults"></div>

                <div class="card">
                    <h3 style="margin-bottom: 16px;">All Entries (${currentTable.entries.length})</h3>
                    <div style="display: grid; gap: 8px;">
                        ${currentTable.entries.map((entry, i) => `
                            <div style="padding: 12px; background: var(--bg-secondary); border-radius: 8px; display: flex; justify-content: space-between;">
                                <span>${i + 1}. ${escapeHtml(entry.text)}</span>
                                ${currentTable.weighted ? `<span style="color: var(--text-secondary); font-size: 13px;">Weight: ${entry.weight}</span>` : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Roll with weights using Alias Method for O(1) performance
        function rollWeighted(entries, tableId = null) {
            if (entries.length === 0) return null;
            if (entries.length === 1) return entries[0];

            // Build weighted distribution using Walker's Alias Method
            const weights = entries.map(e => e.weight || 1);
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            
            // Normalize weights
            const n = weights.length;
            const prob = weights.map(w => w * n / totalWeight);
            
            // Initialize alias tables
            const alias = new Array(n);
            const probTable = new Array(n);
            const small = [];
            const large = [];
            
            // Classify probabilities
            for (let i = 0; i < n; i++) {
                if (prob[i] < 1.0) {
                    small.push(i);
                } else {
                    large.push(i);
                }
            }
            
            // Build alias table
            while (small.length > 0 && large.length > 0) {
                const l = small.pop();
                const g = large.pop();
                
                probTable[l] = prob[l];
                alias[l] = g;
                
                prob[g] = (prob[g] + prob[l]) - 1.0;
                
                if (prob[g] < 1.0) {
                    small.push(g);
                } else {
                    large.push(g);
                }
            }
            
            while (large.length > 0) {
                probTable[large.pop()] = 1.0;
            }
            
            while (small.length > 0) {
                probTable[small.pop()] = 1.0;
            }
            
            // Sample from alias table with anti-repetition
            let selectedIndex;
            const availableIndices = tableId ? getAvailableIndices(entries, tableId) : null;
            
            // Try up to 10 times to avoid recent results
            for (let attempt = 0; attempt < 10; attempt++) {
                const u = getSecureRandom();
                const i = getSecureRandomInt(0, n);
                selectedIndex = (u < probTable[i]) ? i : alias[i];
                
                if (!availableIndices || availableIndices.includes(selectedIndex)) {
                    break;
                }
            }
            
            if (tableId) {
                addToRecentRolls(tableId, selectedIndex);
            }
            
            return entries[selectedIndex];
        }

        // Unweighted roll with anti-repetition
        function rollUnweighted(entries, tableId = null) {
            if (entries.length === 0) return null;
            if (entries.length === 1) return entries[0];
            
            const availableIndices = tableId ? getAvailableIndices(entries, tableId) : entries.map((_, i) => i);
            
            if (availableIndices.length === 0) {
                // Fallback: clear history and pick any
                if (tableId) recentRolls.delete(tableId);
                const index = getSecureRandomInt(0, entries.length);
                return entries[index];
            }
            
            const randomIndex = getSecureRandomInt(0, availableIndices.length);
            const selectedIndex = availableIndices[randomIndex];
            
            if (tableId) {
                addToRecentRolls(tableId, selectedIndex);
            }
            
            return entries[selectedIndex];
        }

        // Process dice formulas in text
        function processDiceInText(text) {
            const diceRegex = /\{(\d+d\d+(?:[+-]\d+)?)\}/g;
            return text.replace(diceRegex, (match, formula) => {
                try {
                    const result = parseDiceFormula(formula);
                    return `<strong>${result.total}</strong>`;
                } catch {
                    return match;
                }
            });
        }

        // Roll table with chain support
        function rollTable(silent = false) {
            if (!currentTable || currentTable.entries.length === 0) return;
            
            const entry = currentTable.weighted ? 
                rollWeighted(currentTable.entries, currentTable.id) :
                rollUnweighted(currentTable.entries, currentTable.id);
            
            if (!entry) {
                alert('Error rolling table');
                return;
            }
            
            const result = entry.text;
            const processedResult = processDiceInText(result);
            
            // Check if rare (weight 1-2 in weighted tables)
            const isRare = currentTable.weighted && entry.weight <= 2;
            
            // Execute roll chains if configured
            const chainResults = [];
            if (entry.chains && entry.chains.length > 0) {
                entry.chains.forEach(chainTableId => {
                    const chainTable = tables.find(t => t.id === chainTableId);
                    if (chainTable && chainTable.entries.length > 0) {
                        const chainEntry = chainTable.weighted ?
                            rollWeighted(chainTable.entries, chainTable.id) :
                            rollUnweighted(chainTable.entries, chainTable.id);
                        if (chainEntry) {
                            chainResults.push({
                                tableName: chainTable.name,
                                result: processDiceInText(chainEntry.text)
                            });
                            // Increment chain table roll count
                            chainTable.rollCount = (chainTable.rollCount || 0) + 1;
                        }
                    }
                });
                // Save after incrementing chain table counts
                if (chainResults.length > 0) {
                    saveTables();
                }
            }
            
            if (!silent) {
                playSound(isRare ? 880 : 440, 150);
                if (isRare) {
                    createConfetti();
                    document.body.classList.add('shake');
                    setTimeout(() => document.body.classList.remove('shake'), 500);
                }
            }
            
            currentTable.rollCount = (currentTable.rollCount || 0) + 1;
            saveTables();
            
            // Add to history with chains
            const fullResult = result + (chainResults.length > 0 ? 
                ' ‚Üí ' + chainResults.map(cr => `${cr.tableName}: ${cr.result}`).join(' ‚Üí ') : '');
            addToHistory(currentTable.name, fullResult);
            
            const resultsDiv = document.getElementById('rollResults');
            resultsDiv.innerHTML = `
                <div class="roll-result ${isRare ? 'rare' : ''}">
                    <h2>üé≤ Result${isRare ? ' ‚ú® RARE!' : ''}</h2>
                    <p>${processedResult}</p>
                    ${chainResults.length > 0 ? `
                        <div class="chain-result">
                            ${chainResults.map(cr => `
                                <div class="chain-result-item">
                                    <div class="chain-result-label">‚Ü≥ ${escapeHtml(cr.tableName)}</div>
                                    <div>${cr.result}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    <div class="action-bar" style="justify-content: center;">
                        <button class="btn btn-secondary no-print" onclick="copyToClipboard(\`${escapeHtml(fullResult.replace(/<[^>]*>/g, ''))}\`)">üìã Copy</button>
                        <button class="btn btn-secondary no-print" onclick="rollTable()">‚Üª Reroll</button>
                    </div>
                </div>
            `;
        }

        // Roll multiple with chain support
        function rollMultiple(count = 3) {
            if (!currentTable || currentTable.entries.length === 0) return;
            
            const results = [];
            for (let i = 0; i < count; i++) {
                const entry = currentTable.weighted ? 
                    rollWeighted(currentTable.entries, currentTable.id) :
                    rollUnweighted(currentTable.entries, currentTable.id);
                
                if (entry) {
                    const mainResult = entry.text;
                    
                    // Execute chains for this entry
                    const chainResults = [];
                    if (entry.chains && entry.chains.length > 0) {
                        entry.chains.forEach(chainTableId => {
                            const chainTable = tables.find(t => t.id === chainTableId);
                            if (chainTable && chainTable.entries.length > 0) {
                                const chainEntry = chainTable.weighted ?
                                    rollWeighted(chainTable.entries, chainTable.id) :
                                    rollUnweighted(chainTable.entries, chainTable.id);
                                if (chainEntry) {
                                    chainResults.push({
                                        tableName: chainTable.name,
                                        result: processDiceInText(chainEntry.text)
                                    });
                                    chainTable.rollCount = (chainTable.rollCount || 0) + 1;
                                }
                            }
                        });
                        // Save after chain counts
                        if (chainResults.length > 0) {
                            saveTables();
                        }
                    }
                    
                    results.push({
                        main: mainResult,
                        chains: chainResults
                    });
                }
            }
            
            playSound(440, 150);
            currentTable.rollCount = (currentTable.rollCount || 0) + count;
            saveTables();
            
            const fullResult = results.map((r, idx) => 
                `${idx + 1}. ${r.main}` + 
                (r.chains.length > 0 ? ' ‚Üí ' + r.chains.map(c => `${c.tableName}: ${c.result}`).join(' ‚Üí ') : '')
            ).join(' | ');
            addToHistory(currentTable.name, fullResult);
            
            const resultsDiv = document.getElementById('rollResults');
            resultsDiv.innerHTML = `
                <div class="roll-result">
                    <h2>üé≤ ${count}x Results</h2>
                    ${results.map((r, i) => `
                        <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px;">
                            <p style="margin-bottom: ${r.chains.length > 0 ? '8px' : '0'};">${i + 1}. ${processDiceInText(r.main)}</p>
                            ${r.chains.length > 0 ? `
                                <div class="chain-result">
                                    ${r.chains.map(cr => `
                                        <div class="chain-result-item">
                                            <div class="chain-result-label">‚Ü≥ ${escapeHtml(cr.tableName)}</div>
                                            <div>${cr.result}</div>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                        </div>
                    `).join('')}
                    <button class="btn btn-secondary no-print" style="margin-top: 16px;" onclick="rollMultiple(${count})">‚Üª Reroll All</button>
                </div>
            `;
        }

        // Roll with advantage
        function rollWithAdvantage() {
            if (!currentTable || currentTable.entries.length === 0) return;
            
            // Temporarily disable anti-repetition for advantage rolls
            const tableId = currentTable.id;
            const savedHistory = recentRolls.get(tableId);
            recentRolls.delete(tableId);
            
            const roll1 = currentTable.weighted ? 
                rollWeighted(currentTable.entries, null) :
                rollUnweighted(currentTable.entries, null);
            
            const roll2 = currentTable.weighted ? 
                rollWeighted(currentTable.entries, null) :
                rollUnweighted(currentTable.entries, null);
            
            // Restore history
            if (savedHistory) {
                recentRolls.set(tableId, savedHistory);
            }
            
            playSound(440, 150);
            currentTable.rollCount = (currentTable.rollCount || 0) + 2;
            saveTables();
            
            const resultsDiv = document.getElementById('rollResults');
            resultsDiv.innerHTML = `
                <div class="roll-result">
                    <h2>üé≤ Roll with Advantage</h2>
                    <p style="margin-top: 12px; opacity: 0.7;">Option 1: ${processDiceInText(roll1.text)}</p>
                    <p style="margin-top: 12px; opacity: 0.7;">Option 2: ${processDiceInText(roll2.text)}</p>
                    <p style="margin-top: 16px; font-size: 14px;">Choose the result you prefer!</p>
                </div>
            `;
        }

        // Dice roller
        function showDiceRoller() {
            document.getElementById('homeView').classList.add('hidden');
            document.getElementById('tableView').classList.add('hidden');
            document.getElementById('diceView').classList.remove('hidden');
        }

        function rollDice(sides) {
            const result = getSecureRandomInt(1, sides + 1);
            playSound(440, 100);
            addToHistory(`d${sides}`, `${result}`, `d${sides}`);
            
            const resultsDiv = document.getElementById('diceResults');
            resultsDiv.innerHTML = `
                <div class="roll-result">
                    <h2>üé≤ d${sides}</h2>
                    <p style="font-size: 48px; font-weight: bold;">${result}</p>
                </div>
            `;
        }

        function rollCustomDice() {
            const formula = document.getElementById('customDice').value.trim();
            if (!formula) return;

            try {
                const result = parseDiceFormula(formula);
                playSound(440, 100);
                addToHistory(formula, `${result.total}`);
                
                const resultsDiv = document.getElementById('diceResults');
                resultsDiv.innerHTML = `
                    <div class="roll-result">
                        <h2>üé≤ ${escapeHtml(formula)}</h2>
                        <p style="font-size: 36px; font-weight: bold;">${result.total}</p>
                        <p style="font-size: 14px; opacity: 0.8; margin-top: 8px;">${result.breakdown}</p>
                    </div>
                `;
            } catch (e) {
                alert('Invalid dice formula. Use format like: 2d6+3, 1d20-1, 3d8');
            }
        }

        function parseDiceFormula(formula) {
            const match = formula.match(/^(\d+)d(\d+)([+-]\d+)?$/i);
            if (!match) throw new Error('Invalid format');

            const count = parseInt(match[1]);
            const sides = parseInt(match[2]);
            const modifier = match[3] ? parseInt(match[3]) : 0;

            const rolls = [];
            for (let i = 0; i < count; i++) {
                rolls.push(getSecureRandomInt(1, sides + 1));
            }

            const sum = rolls.reduce((a, b) => a + b, 0);
            const total = sum + modifier;

            const breakdown = `Rolls: [${rolls.join(', ')}]${modifier !== 0 ? ` ${modifier > 0 ? '+' : ''}${modifier}` : ''} = ${total}`;

            return { total, breakdown, rolls };
        }

        // Multi-table roll
        function showMultiRoll() {
            const modal = document.getElementById('multiRollModal');
            const list = document.getElementById('multiRollList');
            
            list.innerHTML = tables.map(table => `
                <div class="checkbox-group">
                    <input type="checkbox" id="multi-${table.id}" value="${table.id}">
                    <label for="multi-${table.id}" style="margin: 0;">${escapeHtml(table.name)}</label>
                </div>
            `).join('');
            
            modal.classList.add('active');
        }

        function closeMultiRollModal() {
            document.getElementById('multiRollModal').classList.remove('active');
        }

        function executeMultiRoll() {
            const checkboxes = document.querySelectorAll('#multiRollList input:checked');
            if (checkboxes.length === 0) {
                alert('Please select at least one table');
                return;
            }
            
            const results = [];
            checkboxes.forEach(cb => {
                const table = tables.find(t => t.id === cb.value);
                if (table) {
                    const entry = table.weighted ? 
                        rollWeighted(table.entries, table.id) :
                        rollUnweighted(table.entries, table.id);
                    if (entry) {
                        const mainResult = entry.text;
                        
                        // Execute chains for multi-roll
                        const chainResults = [];
                        if (entry.chains && entry.chains.length > 0) {
                            entry.chains.forEach(chainTableId => {
                                const chainTable = tables.find(t => t.id === chainTableId);
                                if (chainTable && chainTable.entries.length > 0) {
                                    const chainEntry = chainTable.weighted ?
                                        rollWeighted(chainTable.entries, chainTable.id) :
                                        rollUnweighted(chainTable.entries, chainTable.id);
                                    if (chainEntry) {
                                        chainResults.push({
                                            tableName: chainTable.name,
                                            result: processDiceInText(chainEntry.text)
                                        });
                                        chainTable.rollCount = (chainTable.rollCount || 0) + 1;
                                    }
                                }
                            });
                            if (chainResults.length > 0) {
                                saveTables();
                            }
                        }
                        
                        results.push({ 
                            table: table.name, 
                            result: mainResult,
                            chains: chainResults 
                        });
                        table.rollCount = (table.rollCount || 0) + 1;
                    }
                }
            });
            
            saveTables();
            playSound(440, 150);
            
            const tableIds = Array.from(checkboxes).map(cb => cb.value);
            const fullResult = results.map(r => 
                `${r.table}: ${r.result}` + 
                (r.chains.length > 0 ? ' ‚Üí ' + r.chains.map(c => `${c.tableName}: ${c.result}`).join(' ‚Üí ') : '')
            ).join(' | ');
            addToHistory('Multi-Roll', fullResult, 'multi-roll', { tableIds });
            
            closeMultiRollModal();
            
            // Show inline result with chains
            showMultiRollResultWithChains(results);
        }

        function showMultiRollResultWithChains(results) {
            const existingResult = document.getElementById('quickRollResult');
            if (existingResult) existingResult.remove();

            const resultDiv = document.createElement('div');
            resultDiv.id = 'quickRollResult';
            resultDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 1001;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            const processedResults = results.map(r => ({
                table: r.table,
                result: processDiceInText(r.result),
                chains: r.chains
            }));
            
            resultDiv.innerHTML = `
                <div class="roll-result" style="animation: slideIn 0.3s ease-out;">
                    <button onclick="closeQuickRollResult()" style="position: absolute; top: 12px; right: 12px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; opacity: 0.8;">&times;</button>
                    <h2>üéØ Multi-Table Roll</h2>
                    <div style="margin-top: 20px; text-align: left;">
                        ${processedResults.map(r => `
                            <div style="margin-bottom: 16px; padding: 12px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                                <strong style="display: block; margin-bottom: 6px;">${escapeHtml(r.table)}</strong>
                                <div>${r.result}</div>
                                ${r.chains.length > 0 ? `
                                    <div class="chain-result">
                                        ${r.chains.map(cr => `
                                            <div class="chain-result-item">
                                                <div class="chain-result-label">‚Ü≥ ${escapeHtml(cr.tableName)}</div>
                                                <div>${cr.result}</div>
                                            </div>
                                        `).join('')}
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}
                    </div>
                    <div class="action-bar" style="justify-content: center; margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="copyMultiRollResults(${JSON.stringify(processedResults.map(r => 
                            `${r.table}: ${r.result}` + 
                            (r.chains.length > 0 ? ' ‚Üí ' + r.chains.map(c => `${c.tableName}: ${c.result}`).join(' ‚Üí ') : '')
                        )).replace(/"/g, '&quot;')})">üìã Copy All</button>
                        <button class="btn btn-secondary" onclick="closeQuickRollResult(); showMultiRoll()">‚Üª Reroll</button>
                    </div>
                </div>
            `;

            const backdrop = document.createElement('div');
            backdrop.id = 'quickRollBackdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
            `;
            backdrop.onclick = closeQuickRollResult;

            document.body.appendChild(backdrop);
            document.body.appendChild(resultDiv);
        }

        function rerollMultiTableFromHistory(tableIds) {
            showMultiRoll();
            setTimeout(() => {
                tableIds.forEach(id => {
                    const checkbox = document.querySelector(`#multiRollList input[value="${id}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }, 100);
        }

        function copyMultiRollResults(results) {
            copyToClipboard(results.join('\n\n'));
        }

        // Combo Builder System
        function showComboBuilder() {
            editingComboId = null;
            document.getElementById('comboModalTitle').textContent = 'Combo Builder';
            document.getElementById('comboName').value = '';
            document.getElementById('comboTemplate').value = '';
            document.getElementById('comboTableSlots').innerHTML = '';
            addComboSlot();
            addComboSlot();
            switchComboTab('create');
            document.getElementById('comboBuilderModal').classList.add('active');
        }

        function closeComboBuilder() {
            document.getElementById('comboBuilderModal').classList.remove('active');
        }

        function showComboHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelpModal() {
            document.getElementById('helpModal').classList.remove('active');
        }

        function switchComboTab(tab) {
            document.querySelectorAll('#comboBuilderModal .tab').forEach(t => t.classList.remove('active'));
            event?.target?.classList.add('active');
            
            if (tab === 'create') {
                document.getElementById('comboCreateTab').classList.remove('hidden');
                document.getElementById('comboSavedTab').classList.add('hidden');
            } else {
                document.getElementById('comboCreateTab').classList.add('hidden');
                document.getElementById('comboSavedTab').classList.remove('hidden');
                renderSavedCombos();
            }
        }

        function addComboSlot() {
            const container = document.getElementById('comboTableSlots');
            const slotIndex = container.children.length;
            
            const div = document.createElement('div');
            div.className = 'entry-item';
            div.style.background = 'var(--bg-card)';
            
            div.innerHTML = `
                <span style="min-width: 50px; font-weight: 600;">{${slotIndex}}</span>
                <select class="combo-table-select" style="flex: 1; padding: 10px;">
                    <option value="">-- Select Table --</option>
                    ${tables.map(t => `<option value="${t.id}">${escapeHtml(t.name)}</option>`).join('')}
                </select>
                <button class="btn btn-danger btn-sm" onclick="this.parentElement.remove(); updateComboSlotIndices()">√ó</button>
            `;
            
            container.appendChild(div);
        }

        function updateComboSlotIndices() {
            const slots = document.querySelectorAll('#comboTableSlots .entry-item');
            slots.forEach((slot, index) => {
                slot.querySelector('span').textContent = `{${index}}`;
            });
        }

        function validateCombo() {
            const template = document.getElementById('comboTemplate').value.trim();
            const selects = document.querySelectorAll('.combo-table-select');
            
            if (!template) {
                return { valid: false, message: 'Please enter a template' };
            }

            // Find all placeholders in template
            const placeholders = (template.match(/\{(\d+)\}/g) || []).map(p => parseInt(p.match(/\d+/)[0]));
            const maxPlaceholder = Math.max(...placeholders, -1);

            // Check if we have enough table slots
            if (maxPlaceholder >= selects.length) {
                return { 
                    valid: false, 
                    message: `Template uses {${maxPlaceholder}} but you only have ${selects.length} table slots. Add more table slots or fix the template.` 
                };
            }

            // Check if required tables are selected
            const requiredSlots = new Set(placeholders);
            const emptySlots = [];
            
            requiredSlots.forEach(index => {
                if (index < selects.length && !selects[index].value) {
                    emptySlots.push(index);
                }
            });

            if (emptySlots.length > 0) {
                return { 
                    valid: false, 
                    message: `Please select tables for slots: ${emptySlots.map(i => `{${i}}`).join(', ')}` 
                };
            }

            // Check if selected tables have entries
            const emptyTables = [];
            requiredSlots.forEach(index => {
                if (index < selects.length) {
                    const tableId = selects[index].value;
                    const table = tables.find(t => t.id === tableId);
                    if (table && table.entries.length === 0) {
                        emptyTables.push(`{${index}} (${table.name})`);
                    }
                }
            });

            if (emptyTables.length > 0) {
                return { 
                    valid: false, 
                    message: `These tables are empty: ${emptyTables.join(', ')}. Add entries first.` 
                };
            }

            return { valid: true };
        }

        function previewCombo() {
            const validation = validateCombo();
            
            if (!validation.valid) {
                document.getElementById('comboPreview').innerHTML = `
                    <span style="color: var(--danger);">‚ö†Ô∏è ${validation.message}</span>
                `;
                return;
            }

            const template = document.getElementById('comboTemplate').value.trim();
            const selects = document.querySelectorAll('.combo-table-select');
            
            let result = template;
            selects.forEach((select, index) => {
                const tableId = select.value;
                if (tableId) {
                    const table = tables.find(t => t.id === tableId);
                    if (table && table.entries.length > 0) {
                        const entry = table.weighted ? 
                            rollWeighted(table.entries, table.id) :
                            rollUnweighted(table.entries, table.id);
                        if (entry) {
                            result = result.replace(new RegExp(`\\{${index}\\}`, 'g'), `<strong>${escapeHtml(entry.text)}</strong>`);
                        }
                    }
                }
            });

            document.getElementById('comboPreview').innerHTML = result;
        }

        function rollCombo() {
            const validation = validateCombo();
            if (!validation.valid) {
                alert('‚ö†Ô∏è ' + validation.message);
                return;
            }

            const comboName = document.getElementById('comboName').value.trim() || 'Unnamed Combo';
            const template = document.getElementById('comboTemplate').value.trim();
            const selects = document.querySelectorAll('.combo-table-select');
            const tableSlots = Array.from(selects).map(s => s.value);

            let result = template;
            const usedTables = [];
            const allChainResults = [];

            tableSlots.forEach((tableId, index) => {
                if (tableId) {
                    const table = tables.find(t => t.id === tableId);
                    if (table && table.entries.length > 0) {
                        const entry = table.weighted ?
                            rollWeighted(table.entries, table.id) :
                            rollUnweighted(table.entries, table.id);

                        if (entry) {
                            result = result.replace(new RegExp(`\\{${index}\\}`, 'g'), entry.text);
                            usedTables.push(table.name);
                            table.rollCount = (table.rollCount || 0) + 1;

                            // Execute chains
                            if (entry.chains && entry.chains.length > 0) {
                                entry.chains.forEach(chainTableId => {
                                    const chainTable = tables.find(t => t.id === chainTableId);
                                    if (chainTable && chainTable.entries.length > 0) {
                                        const chainEntry = chainTable.weighted ?
                                            rollWeighted(chainTable.entries, chainTable.id) :
                                            rollUnweighted(chainTable.entries, chainTable.id);
                                        if (chainEntry) {
                                            allChainResults.push({
                                                sourceTable: table.name,
                                                tableName: chainTable.name,
                                                result: processDiceInText(chainEntry.text)
                                            });
                                            chainTable.rollCount = (chainTable.rollCount || 0) + 1;
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
            });

            const processedResult = processDiceInText(result);
            saveTables();
            playSound(440, 150);

            const metadata = { name: comboName, template, tableSlots };
            
            let fullResultForHistory = result;
            if (allChainResults.length > 0) {
                fullResultForHistory += ' ‚Üí ' + allChainResults.map(cr => `${cr.tableName}: ${cr.result.replace(/<[^>]*>/g, '')}`).join(' ‚Üí ');
            }

            addToHistory('Combo: ' + comboName, fullResultForHistory, 'combo', metadata);

            closeComboBuilder();
            showComboResultWithReroll(comboName, processedResult, usedTables, metadata, allChainResults);
        }

        function showComboResult(comboName, result, usedTables) {
            const existingResult = document.getElementById('quickRollResult');
            if (existingResult) existingResult.remove();

            const resultDiv = document.createElement('div');
            resultDiv.id = 'quickRollResult';
            resultDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 1001;
                max-width: 600px;
                width: 90%;
            `;
            
            resultDiv.innerHTML = `
                <div class="roll-result" style="animation: slideIn 0.3s ease-out;">
                    <button onclick="closeQuickRollResult()" style="position: absolute; top: 12px; right: 12px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; opacity: 0.8;">&times;</button>
                    <h2>‚ú® ${escapeHtml(comboName)}</h2>
                    <p style="margin-top: 20px; font-size: 18px; line-height: 1.6;">${result}</p>
                    ${usedTables.length > 0 ? `
                        <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                            <small style="opacity: 0.8;">Tables used: ${usedTables.map(t => escapeHtml(t)).join(', ')}</small>
                        </div>
                    ` : ''}
                    <div class="action-bar" style="justify-content: center; margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="copyToClipboard('${escapeHtml(result.replace(/<[^>]*>/g, ''))}')">üìã Copy</button>
                        <button class="btn btn-secondary" onclick="closeQuickRollResult(); showComboBuilder()">‚Üª New Combo</button>
                    </div>
                </div>
            `;

            const backdrop = document.createElement('div');
            backdrop.id = 'quickRollBackdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
            `;
            backdrop.onclick = closeQuickRollResult;

            document.body.appendChild(backdrop);
            document.body.appendChild(resultDiv);
        }

        function saveCombo() {
            const validation = validateCombo();
            
            if (!validation.valid) {
                showToast(validation.message, 'error', 'Cannot save combo');
                return;
            }

            const name = document.getElementById('comboName').value.trim();
            if (!name) {
                showToast('Please enter a combo name', 'warning');
                return;
            }

            const template = document.getElementById('comboTemplate').value.trim();
            const selects = document.querySelectorAll('.combo-table-select');
            const tableSlots = Array.from(selects).map(s => s.value);

            const combo = {
                id: editingComboId || 'combo-' + Date.now(),
                name,
                template,
                tableSlots,
                created: Date.now()
            };

            if (editingComboId) {
                const index = savedCombos.findIndex(c => c.id === editingComboId);
                if (index !== -1) savedCombos[index] = combo;
                showToast('Combo template updated', 'success');
            } else {
                savedCombos.push(combo);
                showToast('Combo template saved', 'success');
            }

            saveCombos();
            switchComboTab('saved');
        }

        function renderSavedCombos() {
            const container = document.getElementById('savedCombosList');
            
            if (savedCombos.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <h2>No Saved Combos</h2>
                        <p>Create and save combo templates for quick generation</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = savedCombos.map(combo => {
                const tableNames = combo.tableSlots
                    .filter(id => id)
                    .map(id => {
                        const table = tables.find(t => t.id === id);
                        return table ? table.name : 'Unknown';
                    });

                return `
                    <div class="card" style="margin-bottom: 16px;">
                        <h3>${escapeHtml(combo.name)}</h3>
                        <p style="color: var(--text-secondary); font-size: 14px; margin: 8px 0;">
                            ${escapeHtml(combo.template)}
                        </p>
                        <div style="display: flex; gap: 4px; flex-wrap: wrap; margin: 12px 0;">
                            ${tableNames.map(name => `<span class="tag">${escapeHtml(name)}</span>`).join('')}
                        </div>
                        <div class="action-bar" style="margin-top: 12px;">
                            <button class="btn btn-primary btn-sm" onclick="loadAndRollCombo('${combo.id}')">üé≤ Roll</button>
                            <button class="btn btn-secondary btn-sm" onclick="loadCombo('${combo.id}')">Edit</button>
                            <button class="btn btn-secondary btn-sm" onclick="exportSingleCombo('${combo.id}')">Export</button>
                            <button class="btn btn-danger btn-sm" onclick="deleteCombo('${combo.id}')">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function loadCombo(id) {
            const combo = savedCombos.find(c => c.id === id);
            if (!combo) return;

            editingComboId = id;
            document.getElementById('comboModalTitle').textContent = 'Edit Combo';
            document.getElementById('comboName').value = combo.name;
            document.getElementById('comboTemplate').value = combo.template;
            
            const container = document.getElementById('comboTableSlots');
            container.innerHTML = '';
            
            combo.tableSlots.forEach(tableId => {
                addComboSlot();
                const lastSelect = container.lastElementChild.querySelector('.combo-table-select');
                lastSelect.value = tableId;
            });

            switchComboTab('create');
        }

        function loadAndRollCombo(id) {
            const combo = savedCombos.find(c => c.id === id);
            if (!combo) return;

            let result = combo.template;
            const usedTables = [];
            const allChainResults = [];
            const comboName = combo.name;

            combo.tableSlots.forEach((tableId, index) => {
                if (tableId) {
                    const table = tables.find(t => t.id === tableId);
                    if (table && table.entries.length > 0) {
                        const entry = table.weighted ?
                            rollWeighted(table.entries, table.id) :
                            rollUnweighted(table.entries, table.id);

                        if (entry) {
                            result = result.replace(new RegExp(`\\{${index}\\}`, 'g'), entry.text);
                            usedTables.push(table.name);
                            table.rollCount = (table.rollCount || 0) + 1;

                            if (entry.chains && entry.chains.length > 0) {
                                entry.chains.forEach(chainTableId => {
                                    const chainTable = tables.find(t => t.id === chainTableId);
                                    if (chainTable && chainTable.entries.length > 0) {
                                        const chainEntry = chainTable.weighted ?
                                            rollWeighted(chainTable.entries, chainTable.id) :
                                            rollUnweighted(chainTable.entries, chainTable.id);
                                        if (chainEntry) {
                                            allChainResults.push({
                                                sourceTable: table.name,
                                                tableName: chainTable.name,
                                                result: processDiceInText(chainEntry.text)
                                            });
                                            chainTable.rollCount = (chainTable.rollCount || 0) + 1;
                                        }
                                    }
                                });
                            }
                        }
                    }
                }
            });

            const processedResult = processDiceInText(result);
            saveTables();
            playSound(440, 150);

            const metadata = { name: comboName, template: combo.template, tableSlots: combo.tableSlots };
            
            let fullResultForHistory = result;
            if (allChainResults.length > 0) {
                fullResultForHistory += ' ‚Üí ' + allChainResults.map(cr => `${cr.tableName}: ${cr.result.replace(/<[^>]*>/g, '')}`).join(' ‚Üí ');
            }

            addToHistory('Combo: ' + comboName, fullResultForHistory, 'combo', metadata);

            closeComboBuilder();
            showComboResultWithReroll(comboName, processedResult, usedTables, metadata, allChainResults);
        }

        function showComboResultWithReroll(comboName, result, usedTables, metadata, chainResults = []) {
            const existingResult = document.getElementById('quickRollResult');
            if (existingResult) existingResult.remove();

            const resultDiv = document.createElement('div');
            resultDiv.id = 'quickRollResult';
            resultDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 1001;
                max-width: 600px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;

            const fullResultText = result.replace(/<[^>]*>/g, '') +
                (chainResults.length > 0 ? '\\n\\n' + chainResults.map(cr => `‚Ü≥ ${cr.tableName}: ${cr.result.replace(/<[^>]*>/g, '')}`).join('\\n') : '');

            const metadataString = JSON.stringify(metadata).replace(/'/g, "\\'");

            resultDiv.innerHTML = `
                <div class="roll-result" style="animation: slideIn 0.3s ease-out;">
                    <button onclick="closeQuickRollResult()" style="position: absolute; top: 12px; right: 12px; background: none; border: none; color: white; font-size: 24px; cursor: pointer; opacity: 0.8;">&times;</button>
                    <h2>‚ú® ${escapeHtml(comboName)}</h2>
                    <p style="margin-top: 20px; font-size: 18px; line-height: 1.6;">${result}</p>
                    ${chainResults.length > 0 ? `
                        <div class="chain-result" style="text-align: left;">
                            ${chainResults.map(cr => `
                                <div class="chain-result-item">
                                    <div class="chain-result-label">‚Ü≥ from ${escapeHtml(cr.sourceTable || 'Combo')}: ${escapeHtml(cr.tableName)}</div>
                                    <div>${cr.result}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    ${usedTables.length > 0 ? `
                        <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                            <small style="opacity: 0.8;">Tables used: ${usedTables.map(t => escapeHtml(t)).join(', ')}</small>
                        </div>
                    ` : ''}
                    <div class="action-bar" style="justify-content: center; margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="copyToClipboard(\`${escapeHtml(fullResultText)}\`)">üìã Copy All</button>
                        <button class="btn btn-secondary" onclick='rerollComboFromResult(${metadataString})'>‚Üª Reroll</button>
                        <button class="btn btn-primary" onclick="closeQuickRollResult(); showComboBuilder()">New Combo</button>
                    </div>
                </div>
            `;

            const backdrop = document.createElement('div');
            backdrop.id = 'quickRollBackdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
            `;
            backdrop.onclick = closeQuickRollResult;

            document.body.appendChild(backdrop);
            document.body.appendChild(resultDiv);
        }

        // Quick Combos View
        function showQuickCombos() {
            const modal = document.getElementById('quickCombosModal');
            const list = document.getElementById('quickCombosList');
            
            if (savedCombos.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <h2>No Saved Combos</h2>
                        <p>Create combo templates in the Combo Builder first!</p>
                        <button class="btn btn-primary" onclick="closeQuickCombos(); showComboBuilder()" style="margin-top: 16px;">
                            Create First Combo
                        </button>
                    </div>
                `;
                modal.classList.add('active');
                return;
            }

            list.innerHTML = savedCombos.map(combo => {
                const tableNames = combo.tableSlots
                    .filter(id => id)
                    .map(id => {
                        const table = tables.find(t => t.id === id);
                        return table ? table.name : 'Unknown';
                    });

                return `
                    <div class="card" style="margin-bottom: 12px; cursor: pointer; transition: all 0.2s;" 
                         onclick="quickRollCombo('${combo.id}')"
                         onmouseover="this.style.transform='translateY(-2px)'" 
                         onmouseout="this.style.transform='translateY(0)'">
                        <h3>${escapeHtml(combo.name)}</h3>
                        <p style="color: var(--text-secondary); font-size: 13px; margin: 8px 0; font-family: monospace;">
                            ${escapeHtml(combo.template.substring(0, 80))}${combo.template.length > 80 ? '...' : ''}
                        </p>
                        <div style="display: flex; gap: 4px; flex-wrap: wrap; margin-bottom: 8px;">
                            ${tableNames.map(name => `<span class="tag" style="font-size: 10px;">${escapeHtml(name)}</span>`).join('')}
                        </div>
                        <button class="btn btn-primary btn-sm" onclick="event.stopPropagation(); quickRollCombo('${combo.id}')" style="width: 100%;">
                            üé≤ Roll Now
                        </button>
                    </div>
                `;
            }).join('');
            
            modal.classList.add('active');
        }

        function closeQuickCombos() {
            document.getElementById('quickCombosModal').classList.remove('active');
        }

        function quickRollCombo(comboId) {
            closeQuickCombos();
            loadAndRollCombo(comboId);
        }

        function deleteCombo(id) {
            if (!confirm('Delete this combo template?')) return;
            
            savedCombos = savedCombos.filter(c => c.id !== id);
            saveCombos();
            renderSavedCombos();
        }

        // Export/Import Combos
        function exportSingleCombo(id) {
            const combo = savedCombos.find(c => c.id === id);
            if (!combo) return;

            const data = JSON.stringify(combo, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `combo_${combo.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Combo exported', 'success');
        }

        function exportAllCombos() {
            if (savedCombos.length === 0) {
                showToast('No combos to export', 'warning');
                return;
            }

            const data = JSON.stringify(savedCombos, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `all_combos_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`${savedCombos.length} combos exported`, 'success');
        }

        function importCombos() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json,.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        // Check if it's a single combo or array of combos
                        const importedCombos = Array.isArray(data) ? data : [data];
                        
                        let imported = 0;
                        let skipped = 0;
                        
                        importedCombos.forEach(combo => {
                            // Validate combo structure
                            if (combo.name && combo.template && Array.isArray(combo.tableSlots)) {
                                // Check if tables exist
                                const missingTables = [];
                                combo.tableSlots.forEach(tableId => {
                                    if (tableId && !tables.find(t => t.id === tableId)) {
                                        missingTables.push(tableId);
                                    }
                                });

                                if (missingTables.length > 0) {
                                    console.warn(`Combo "${combo.name}" references missing tables:`, missingTables);
                                    // Still import but warn user
                                }

                                // Generate new ID to avoid conflicts
                                combo.id = 'combo-' + Date.now() + '-' + imported;
                                combo.created = Date.now();
                                
                                savedCombos.push(combo);
                                imported++;
                            } else {
                                skipped++;
                            }
                        });
                        
                        if (imported > 0) {
                            saveCombos();
                            renderSavedCombos();
                            
                            let message = `Successfully imported ${imported} combo${imported > 1 ? 's' : ''}`;
                            if (skipped > 0) {
                                message += `. ${skipped} skipped (invalid format)`;
                            }
                            
                            const combosWithMissingTables = savedCombos.filter(combo => 
                                combo.tableSlots.some(tableId => tableId && !tables.find(t => t.id === tableId))
                            );
                            
                            if (combosWithMissingTables.length > 0) {
                                showToast(message, 'warning', 'Import Complete', 5000);
                                setTimeout(() => {
                                    showToast(`${combosWithMissingTables.length} combo${combosWithMissingTables.length > 1 ? 's reference' : ' references'} missing tables. Edit to reassign.`, 'info', '', 5000);
                                }, 500);
                            } else {
                                showToast(message, 'success');
                            }
                        } else {
                            showToast('No valid combos found in the file', 'error');
                        }
                    } catch (err) {
                        console.error('Import error:', err);
                        alert('‚ùå Error reading file. Please make sure it\'s a valid combo JSON file.');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Table Packs System
        function showTablePacks() {
            const modal = document.getElementById('tablePacksModal');
            const list = document.getElementById('tablePacksList');
            
            list.innerHTML = Object.keys(tablePacks).map(packId => {
                const pack = tablePacks[packId];
                return `
                    <div class="card" style="margin-bottom: 16px; cursor: pointer; transition: all 0.2s;" 
                         onmouseover="this.style.transform='translateY(-2px)'" 
                         onmouseout="this.style.transform='translateY(0)'">
                        <div style="display: flex; align-items: start; gap: 16px;">
                            <div style="font-size: 48px;">${pack.icon}</div>
                            <div style="flex: 1;">
                                <h3 style="margin-bottom: 8px;">${pack.name}</h3>
                                <p style="color: var(--text-secondary); font-size: 14px; margin-bottom: 12px;">
                                    ${pack.description}
                                </p>
                                <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px;">
                                    ${pack.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                                </div>
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: var(--text-secondary); font-size: 13px;">
                                        ${pack.tables.length} tables ‚Ä¢ By ${pack.author}
                                    </span>
                                    <div class="action-bar" style="margin: 0;">
                                        <button class="btn btn-secondary btn-sm" onclick="event.stopPropagation(); previewPack('${packId}')">
                                            Preview
                                        </button>
                                        <button class="btn btn-primary btn-sm" onclick="event.stopPropagation(); importPack('${packId}')">
                                            Import
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            modal.classList.add('active');
        }

        function closeTablePacks() {
            document.getElementById('tablePacksModal').classList.remove('active');
        }

        function previewPack(packId) {
            const pack = tablePacks[packId];
            const modal = document.getElementById('packPreviewModal');
            
            document.getElementById('previewPackTitle').textContent = `${pack.icon} ${pack.name}`;
            
            const content = document.getElementById('packPreviewContent');
            content.innerHTML = `
                <p style="color: var(--text-secondary); margin-bottom: 20px;">${pack.description}</p>
                
                <div style="margin-bottom: 20px;">
                    <strong>What you'll get:</strong>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                        ${pack.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                    </div>
                </div>

                <h4 style="margin-bottom: 12px;">Tables included (${pack.tables.length}):</h4>
                <div style="max-height: 400px; overflow-y: auto;">
                    ${pack.tables.map(table => `
                        <div style="padding: 12px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: start;">
                                <div style="flex: 1;">
                                    <strong>${table.name}</strong>
                                    ${table.weighted ? '<span class="badge pro">WEIGHTED</span>' : ''}
                                    <p style="color: var(--text-secondary); font-size: 13px; margin-top: 4px;">
                                        ${table.description}
                                    </p>
                                    <p style="color: var(--text-secondary); font-size: 12px; margin-top: 4px;">
                                        ${table.entries.length} entries
                                    </p>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            document.getElementById('importPackBtn').onclick = () => {
                closePackPreview();
                importPack(packId);
            };
            
            modal.classList.add('active');
        }

        function closePackPreview() {
            document.getElementById('packPreviewModal').classList.remove('active');
        }

        function importPack(packId) {
            const pack = tablePacks[packId];
            
            // Check if any tables with same names exist
            const existingNames = tables.map(t => t.name.toLowerCase());
            const conflicts = pack.tables.filter(t => existingNames.includes(t.name.toLowerCase()));
            
            if (conflicts.length > 0) {
                const proceed = confirm(
                    `${conflicts.length} table${conflicts.length > 1 ? 's' : ''} with similar names already exist:\n\n` +
                    conflicts.map(t => `‚Ä¢ ${t.name}`).join('\n') +
                    `\n\nImport anyway? (New tables will be added with "_imported" suffix)`
                );
                if (!proceed) return;
            }
            
            let imported = 0;
            pack.tables.forEach(table => {
                // Check for name conflict and add suffix if needed
                let tableName = table.name;
                if (existingNames.includes(tableName.toLowerCase())) {
                    tableName += '_imported';
                }
                
                tables.push({
                    id: 'table-' + Date.now() + '-' + imported,
                    name: tableName,
                    description: table.description || '',
                    weighted: table.weighted || false,
                    tags: table.tags || [],
                    color: 'default',
                    favorite: false,
                    rollCount: 0,
                    entries: table.entries.map(e => ({
                        text: e.text,
                        weight: e.weight || 1,
                        chains: e.chains || []
                    })),
                    created: Date.now()
                });
                imported++;
            });
            
            saveTables();
            closeTablePacks();
            goHome();
            
            showToast(
                `Successfully imported ${imported} tables from ${pack.name}!`,
                'success',
                'Pack Imported',
                4000
            );
        }

        // Merge Tables System
        function showMergeTables() {
            const modal = document.getElementById('mergeTablesModal');
            const list = document.getElementById('mergeTablesList');
            
            if (tables.length < 2) {
                alert('You need at least 2 tables to merge!');
                return;
            }

            list.innerHTML = tables.map(table => `
                <div class="checkbox-group" style="padding: 12px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 8px;">
                    <input type="checkbox" id="merge-${table.id}" value="${table.id}">
                    <label for="merge-${table.id}" style="margin: 0; flex: 1;">
                        <strong>${escapeHtml(table.name)}</strong>
                        <span style="color: var(--text-secondary); font-size: 13px; margin-left: 8px;">
                            (${table.entries.length} entries)
                        </span>
                    </label>
                </div>
            `).join('');
            
            document.getElementById('mergedTableName').value = '';
            modal.classList.add('active');
        }

        function closeMergeModal() {
            document.getElementById('mergeTablesModal').classList.remove('active');
        }

        function executeMerge() {
            const checkboxes = document.querySelectorAll('#mergeTablesList input:checked');
            
            if (checkboxes.length < 2) {
                showToast('Please select at least 2 tables to merge', 'warning');
                return;
            }

            const name = document.getElementById('mergedTableName').value.trim();
            if (!name) {
                showToast('Please enter a name for the merged table', 'warning');
                return;
            }

            const allEntries = [];
            const allTags = new Set();
            let hasWeighted = false;

            checkboxes.forEach(cb => {
                const table = tables.find(t => t.id === cb.value);
                if (table) {
                    allEntries.push(...table.entries);
                    table.tags.forEach(tag => allTags.add(tag));
                    if (table.weighted) hasWeighted = true;
                }
            });

            tables.push({
                id: 'table-' + Date.now(),
                name,
                description: `Merged from ${checkboxes.length} tables: ${Array.from(checkboxes).map(cb => tables.find(t => t.id === cb.value).name).join(', ')}`,
                weighted: hasWeighted,
                tags: Array.from(allTags),
                color: 'default',
                favorite: false,
                rollCount: 0,
                entries: allEntries,
                created: Date.now()
            });

            saveTables();
            closeMergeModal();
            renderTablesList();
            showToast(`Successfully merged ${checkboxes.length} tables into "${name}"`, 'success', '', 4000);
        }

        // Table management
        function createNewTable() {
            editingTableId = null;
            useWeights = false;
            document.getElementById('modalTitle').textContent = 'Create New Table';
            document.getElementById('tableName').value = '';
            document.getElementById('tableDesc').value = '';
            document.getElementById('tableTags').value = '';
            document.getElementById('tableColor').value = 'default';
            document.getElementById('useWeights').checked = false;
            document.getElementById('entriesList').innerHTML = '';
            addEntry('', 1);
            addEntry('', 1);
            document.getElementById('tableModal').classList.add('active');
        }

        function editTable(id) {
            const table = tables.find(t => t.id === id);
            if (!table) return;

            editingTableId = id;
            useWeights = table.weighted || false;
            document.getElementById('modalTitle').textContent = 'Edit Table';
            document.getElementById('tableName').value = table.name;
            document.getElementById('tableDesc').value = table.description || '';
            document.getElementById('tableTags').value = table.tags.join(', ');
            document.getElementById('tableColor').value = table.color || 'default';
            document.getElementById('useWeights').checked = useWeights;
            
            const entriesList = document.getElementById('entriesList');
            entriesList.innerHTML = '';
            table.entries.forEach(entry => addEntry(entry.text, entry.weight || 1, entry.chains || []));
            
            renderChainConfigurator();
            
            document.getElementById('tableModal').classList.add('active');
        }

        function addEntry(value = '', weight = 1, chains = []) {
            const entriesList = document.getElementById('entriesList');
            const div = document.createElement('div');
            div.className = 'entry-item draggable';
            div.draggable = true;
            div.dataset.chains = JSON.stringify(chains);
            
            const weightInput = useWeights ? 
                `<input type="number" min="1" max="100" value="${weight}" placeholder="Weight">` : '';
            
            const chainBadge = chains.length > 0 ? 
                `<span class="badge chain" title="${chains.length} chain${chains.length > 1 ? 's' : ''}" style="margin-left: 8px;">‚õìÔ∏è ${chains.length}</span>` : '';
            
            div.innerHTML = `
                <span class="drag-handle" title="Drag to reorder">‚ãÆ‚ãÆ</span>
                <input type="text" placeholder="Entry text (use {2d6+3} for dice)..." value="${escapeHtml(value)}">
                ${weightInput}
                ${chainBadge}
                <button class="btn btn-danger btn-sm" onclick="removeEntry(this)">√ó</button>
            `;
            
            // Add drag event listeners
            div.addEventListener('dragstart', handleEntryDragStart);
            div.addEventListener('dragend', handleEntryDragEnd);
            div.addEventListener('dragover', handleEntryDragOver);
            div.addEventListener('drop', handleEntryDrop);
            
            entriesList.appendChild(div);
            renderChainConfigurator();
        }

        function removeEntry(btn) {
            btn.parentElement.remove();
            renderChainConfigurator();
        }

        // Roll Chain Configurator
        function renderChainConfigurator() {
            const container = document.getElementById('chainConfigurator');
            const entries = Array.from(document.querySelectorAll('.entry-item'));
            
            if (entries.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary); font-size: 14px;">Add entries first to configure roll chains</p>';
                return;
            }

            container.innerHTML = entries.map((entryDiv, index) => {
                const entryText = entryDiv.querySelector('input[type="text"]').value || `Entry ${index + 1}`;
                const chains = JSON.parse(entryDiv.dataset.chains || '[]');
                
                return `
                    <div class="chain-config">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <strong style="font-size: 14px;">${index + 1}. ${escapeHtml(entryText.substring(0, 50))}${entryText.length > 50 ? '...' : ''}</strong>
                            <button class="btn btn-secondary btn-sm" onclick="addChainToEntry(${index})">+ Add Chain</button>
                        </div>
                        <div id="chains-${index}">
                            ${chains.length === 0 ? 
                                '<p style="color: var(--text-secondary); font-size: 13px;">No chains configured</p>' :
                                chains.map((chainTableId, chainIndex) => {
                                    const chainTable = tables.find(t => t.id === chainTableId);
                                    return `
                                        <div class="chain-item">
                                            <span class="chain-arrow">‚Ü≥</span>
                                            <select onchange="updateChain(${index}, ${chainIndex}, this.value)" style="flex: 1;">
                                                <option value="">-- Select Table --</option>
                                                ${tables.map(t => `
                                                    <option value="${t.id}" ${t.id === chainTableId ? 'selected' : ''}>
                                                        ${escapeHtml(t.name)}
                                                    </option>
                                                `).join('')}
                                            </select>
                                            <button class="btn btn-danger btn-sm" onclick="removeChain(${index}, ${chainIndex})">√ó</button>
                                        </div>
                                    `;
                                }).join('')
                            }
                        </div>
                    </div>
                `;
            }).join('');
        }

        function addChainToEntry(entryIndex) {
            const entries = Array.from(document.querySelectorAll('.entry-item'));
            const entryDiv = entries[entryIndex];
            const chains = JSON.parse(entryDiv.dataset.chains || '[]');
            chains.push('');
            entryDiv.dataset.chains = JSON.stringify(chains);
            renderChainConfigurator();
        }

        function updateChain(entryIndex, chainIndex, tableId) {
            const entries = Array.from(document.querySelectorAll('.entry-item'));
            const entryDiv = entries[entryIndex];
            const chains = JSON.parse(entryDiv.dataset.chains || '[]');
            
            // Check for circular reference
            if (tableId && editingTableId === tableId) {
                showToast('Cannot chain a table to itself (circular reference)', 'error');
                renderChainConfigurator();
                return;
            }
            
            // Check if this table is already in the chain
            if (tableId && chains.includes(tableId)) {
                showToast('Table already in this chain', 'warning');
                renderChainConfigurator();
                return;
            }
            
            chains[chainIndex] = tableId;
            entryDiv.dataset.chains = JSON.stringify(chains);
            
            // Update the badge
            updateChainBadge(entryIndex);
        }

        function removeChain(entryIndex, chainIndex) {
            const entries = Array.from(document.querySelectorAll('.entry-item'));
            const entryDiv = entries[entryIndex];
            const chains = JSON.parse(entryDiv.dataset.chains || '[]');
            chains.splice(chainIndex, 1);
            entryDiv.dataset.chains = JSON.stringify(chains);
            renderChainConfigurator();
            updateChainBadge(entryIndex);
        }

        function updateChainBadge(entryIndex) {
            const entries = Array.from(document.querySelectorAll('.entry-item'));
            const entryDiv = entries[entryIndex];
            const chains = JSON.parse(entryDiv.dataset.chains || '[]').filter(c => c);
            
            // Update or remove badge
            let badge = entryDiv.querySelector('.badge.chain');
            
            if (chains.length > 0) {
                if (!badge) {
                    badge = document.createElement('span');
                    badge.className = 'badge chain';
                    badge.style.marginLeft = '8px';
                    const deleteBtn = entryDiv.querySelector('.btn-danger');
                    deleteBtn.parentNode.insertBefore(badge, deleteBtn);
                }
                badge.textContent = `‚õìÔ∏è ${chains.length}`;
                badge.title = `${chains.length} chain${chains.length > 1 ? 's' : ''}`;
            } else if (badge) {
                badge.remove();
            }
        }

        // Drag & Drop for Entries
        function handleEntryDragStart(e) {
            draggedElement = e.target.closest('.entry-item');
            draggedElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            
            const entries = Array.from(document.querySelectorAll('.entry-item'));
            draggedIndex = entries.indexOf(draggedElement);
        }

        function handleEntryDragEnd(e) {
            e.target.closest('.entry-item').classList.remove('dragging');
            document.querySelectorAll('.entry-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function handleEntryDragOver(e) {
            e.preventDefault();
            const item = e.target.closest('.entry-item');
            if (item && item !== draggedElement) {
                item.classList.add('drag-over');
            }
        }

        function handleEntryDrop(e) {
            e.preventDefault();
            const dropTarget = e.target.closest('.entry-item');
            
            if (dropTarget && dropTarget !== draggedElement) {
                const entries = Array.from(document.querySelectorAll('.entry-item'));
                const dropIndex = entries.indexOf(dropTarget);
                
                if (draggedIndex < dropIndex) {
                    dropTarget.parentNode.insertBefore(draggedElement, dropTarget.nextSibling);
                } else {
                    dropTarget.parentNode.insertBefore(draggedElement, dropTarget);
                }
                
                showToast('Entry reordered', 'success', '', 2000);
            }
            
            dropTarget?.classList.remove('drag-over');
        }

        document.addEventListener('change', (e) => {
            if (e.target.id === 'useWeights') {
                useWeights = e.target.checked;
                const entries = Array.from(document.querySelectorAll('.entry-item'));
                entries.forEach(entry => {
                    const textInput = entry.querySelector('input[type="text"]');
                    const hasWeight = entry.querySelector('input[type="number"]');
                    
                    if (useWeights && !hasWeight) {
                        const weightInput = document.createElement('input');
                        weightInput.type = 'number';
                        weightInput.min = '1';
                        weightInput.max = '100';
                        weightInput.value = '1';
                        weightInput.placeholder = 'Weight';
                        entry.insertBefore(weightInput, entry.lastElementChild);
                    } else if (!useWeights && hasWeight) {
                        hasWeight.remove();
                    }
                });
            }
        });

        function saveTable() {
            const name = document.getElementById('tableName').value.trim();
            if (!name) {
                alert('Please enter a table name');
                return;
            }

            const description = document.getElementById('tableDesc').value.trim();
            const weighted = document.getElementById('useWeights').checked;
            const tagsInput = document.getElementById('tableTags').value.trim();
            const tags = tagsInput ? tagsInput.split(',').map(t => t.trim().toLowerCase()).filter(t => t) : [];
            const color = document.getElementById('tableColor').value;
            const entryItems = document.querySelectorAll('#entriesList .entry-item');
            
            const entries = Array.from(entryItems)
                .map(item => {
                    const text = item.querySelector('input[type="text"]').value.trim();
                    const weightInput = item.querySelector('input[type="number"]');
                    const weight = weightInput ? parseInt(weightInput.value) : 1;
                    const chains = JSON.parse(item.dataset.chains || '[]').filter(c => c);
                    return { text, weight, chains };
                })
                .filter(entry => entry.text.length > 0);

            if (entries.length === 0) {
                alert('Please add at least one entry');
                return;
            }

            if (editingTableId) {
                const table = tables.find(t => t.id === editingTableId);
                table.name = name;
                table.description = description;
                table.weighted = weighted;
                table.tags = tags;
                table.color = color;
                table.entries = entries;
                showToast('Table updated successfully', 'success');
            } else {
                tables.push({
                    id: 'table-' + Date.now(),
                    name,
                    description,
                    weighted,
                    tags,
                    color,
                    favorite: false,
                    rollCount: 0,
                    entries,
                    created: Date.now()
                });
                showToast('Table created successfully', 'success');
            }

            saveTables();
            closeModal();
            
            if (currentTable && editingTableId === currentTable.id) {
                viewTable(editingTableId);
            } else {
                goHome();
            }
        }

        function deleteTable(id) {
            if (!confirm('Are you sure you want to delete this table?')) return;
            
            tables = tables.filter(t => t.id !== id);
            saveTables();
            
            if (currentTable && currentTable.id === id) {
                goHome();
            } else {
                renderTablesList();
            }
        }

        function duplicateTable(id) {
            const table = tables.find(t => t.id === id);
            if (!table) return;

            const newTable = {
                ...table,
                id: 'table-' + Date.now(),
                name: table.name + ' (Copy)',
                rollCount: 0,
                created: Date.now()
            };

            tables.push(newTable);
            saveTables();
            renderTablesList();
            showToast(`"${table.name}" duplicated`, 'success');
        }

        function exportTable(id) {
            const table = tables.find(t => t.id === id);
            if (!table) return;

            const data = JSON.stringify(table, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${table.name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Table exported', 'success');
        }

        function exportAllTables() {
            const data = JSON.stringify(tables, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `all_tables_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`${tables.length} tables exported`, 'success');
        }

        function importTables() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json,.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        const importedTables = Array.isArray(data) ? data : [data];
                        
                        let imported = 0;
                        importedTables.forEach(table => {
                            if (table.name && table.entries && Array.isArray(table.entries)) {
                                table.id = 'table-' + Date.now() + '-' + imported;
                                table.created = Date.now();
                                table.rollCount = 0;
                                
                                if (!table.tags) table.tags = [];
                                if (!table.color) table.color = 'default';
                                if (table.favorite === undefined) table.favorite = false;
                                
                                if (typeof table.entries[0] === 'string') {
                                    table.entries = table.entries.map(e => ({ text: e, weight: 1 }));
                                }
                                
                                tables.push(table);
                                imported++;
                            }
                        });
                        
                        if (imported > 0) {
                            saveTables();
                            renderTablesList();
                            showToast(`Successfully imported ${imported} table${imported > 1 ? 's' : ''}`, 'success');
                        } else {
                            showToast('No valid tables found in the file', 'error');
                        }
                    } catch (err) {
                        showToast('Error reading file. Please make sure it\'s a valid JSON file', 'error');
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }

        function printTable(id) {
            const table = tables.find(t => t.id === id);
            if (!table) return;

            const printWindow = window.open('', '_blank');
            if (!printWindow) {
                alert('Please allow popups to use the print feature');
                return;
            }
            
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${escapeHtml(table.name)}</title>
                    <style>
                        body {
                            font-family: Arial, sans-serif;
                            padding: 40px;
                            max-width: 800px;
                            margin: 0 auto;
                        }
                        h1 { margin-bottom: 10px; }
                        .description { color: #666; margin-bottom: 30px; }
                        .entry {
                            padding: 12px;
                            margin-bottom: 8px;
                            background: #f5f5f5;
                            border-radius: 4px;
                            display: flex;
                            justify-content: space-between;
                        }
                        .weight { color: #666; font-size: 14px; }
                        .footer { margin-top: 40px; font-size: 12px; color: #999; }
                        .tags { margin-bottom: 20px; }
                        .tag { 
                            display: inline-block;
                            padding: 4px 8px;
                            background: #6366f1;
                            color: white;
                            border-radius: 4px;
                            font-size: 12px;
                            margin-right: 8px;
                        }
                    </style>
                </head>
                <body>
                    <h1>üé≤ ${escapeHtml(table.name)}</h1>
                    <p class="description">${escapeHtml(table.description || '')}</p>
                    ${table.tags.length > 0 ? `
                        <div class="tags">
                            ${table.tags.map(tag => `<span class="tag">${escapeHtml(tag)}</span>`).join('')}
                        </div>
                    ` : ''}
                    ${table.weighted ? '<p><strong>‚öñÔ∏è Weighted Table</strong></p>' : ''}
                    <div>
                        ${table.entries.map((entry, i) => `
                            <div class="entry">
                                <span>${i + 1}. ${escapeHtml(entry.text)}</span>
                                ${table.weighted ? `<span class="weight">Weight: ${entry.weight}</span>` : ''}
                            </div>
                        `).join('')}
                    </div>
                    <div class="footer">
                        Generated by Smart Random Generator Pro ‚Ä¢ ${new Date().toLocaleDateString()} ‚Ä¢ ${table.entries.length} entries ‚Ä¢ ${table.rollCount || 0} total rolls
                    </div>
                </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.focus();
            setTimeout(() => {
                printWindow.print();
                printWindow.close();
            }, 250);
        }

        // Bulk operations
        function bulkEdit() {
            if (selectedTables.size === 0) return;
            
            const newWeight = prompt('Enter new weight for all selected entries (1-100):');
            if (!newWeight) return;
            
            const weight = parseInt(newWeight);
            if (isNaN(weight) || weight < 1 || weight > 100) {
                alert('Invalid weight. Please enter a number between 1 and 100.');
                return;
            }
            
            selectedTables.forEach(id => {
                const table = tables.find(t => t.id === id);
                if (table && table.weighted) {
                    table.entries.forEach(entry => entry.weight = weight);
                }
            });
            
            saveTables();
            clearSelection();
            renderTablesList();
            alert('Weights updated!');
        }

        function mergeTables() {
            if (selectedTables.size < 2) {
                alert('Please select at least 2 tables to merge');
                return;
            }
            
            clearSelection();
            showMergeTables();
            
            // Pre-select the tables that were in selection
            selectedTables.forEach(id => {
                const checkbox = document.getElementById(`merge-${id}`);
                if (checkbox) checkbox.checked = true;
            });
        }

        function bulkDelete() {
            if (selectedTables.size === 0) return;
            
            if (!confirm(`Delete ${selectedTables.size} selected tables?`)) return;
            
            tables = tables.filter(t => !selectedTables.has(t.id));
            saveTables();
            clearSelection();
            renderTablesList();
        }

        function clearSelection() {
            selectedTables.clear();
            document.getElementById('multiSelectBar').classList.remove('active');
            renderTablesList();
        }

        // Utility functions
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showToast('Copied to clipboard', 'success', '', 2000);
            }).catch(() => {
                showToast('Failed to copy', 'error', '', 2000);
            });
        }

        function goHome() {
            document.getElementById('homeView').classList.remove('hidden');
            document.getElementById('tableView').classList.add('hidden');
            document.getElementById('diceView').classList.add('hidden');
            currentTable = null;
            switchTab('tables');
        }

        function closeModal() {
            document.getElementById('tableModal').classList.remove('active');
        }

        function toggleTheme() {
            const html = document.documentElement;
            const current = html.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
            document.getElementById('themeToggle').textContent = next === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }

        function loadTheme() {
            const theme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', theme);
            document.getElementById('themeToggle').textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        }

        function setupEventListeners() {
            document.getElementById('createTableBtn').addEventListener('click', createNewTable);
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            document.getElementById('closeModal').addEventListener('click', closeModal);
            document.getElementById('cancelBtn').addEventListener('click', closeModal);
            document.getElementById('saveTableBtn').addEventListener('click', saveTable);
            document.getElementById('addEntryBtn').addEventListener('click', () => addEntry('', 1));
            
            document.getElementById('tableModal').addEventListener('click', (e) => {
                if (e.target.id === 'tableModal') closeModal();
            });

            document.getElementById('customDice').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') rollCustomDice();
            });

            // Search and filter
            document.getElementById('searchInput').addEventListener('input', (e) => {
                currentFilter.search = e.target.value;
                renderTablesList();
            });

            document.getElementById('filterSort').addEventListener('change', (e) => {
                currentFilter.sort = e.target.value;
                renderTablesList();
            });

            document.getElementById('filterType').addEventListener('change', (e) => {
                currentFilter.type = e.target.value;
                renderTablesList();
            });

            document.getElementById('filterTag').addEventListener('change', (e) => {
                currentFilter.tag = e.target.value;
                renderTablesList();
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize
        init();
    </script>
</body>
</html>